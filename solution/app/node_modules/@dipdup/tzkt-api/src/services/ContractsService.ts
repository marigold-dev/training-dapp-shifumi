/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { AccountParameter } from '../models/AccountParameter';
import type { BigMap } from '../models/BigMap';
import type { BigMapKey } from '../models/BigMapKey';
import type { BigMapKeyHistorical } from '../models/BigMapKeyHistorical';
import type { BigMapKeyUpdate } from '../models/BigMapKeyUpdate';
import type { BigMapTagsParameter } from '../models/BigMapTagsParameter';
import type { Contract } from '../models/Contract';
import type { ContractInterface } from '../models/ContractInterface';
import type { ContractKindParameter } from '../models/ContractKindParameter';
import type { Entrypoint } from '../models/Entrypoint';
import type { IMicheline } from '../models/IMicheline';
import type { Int32Parameter } from '../models/Int32Parameter';
import type { JsonParameter } from '../models/JsonParameter';
import type { MichelineFormat } from '../models/MichelineFormat';
import type { OffsetParameter } from '../models/OffsetParameter';
import type { SelectParameter } from '../models/SelectParameter';
import type { SortParameter } from '../models/SortParameter';
import type { StorageRecord } from '../models/StorageRecord';
import { ApiRequestOptions } from '../core/ApiRequestOptions';
import { request as __request } from '../core/request';
import { ApiOptions } from '../core/ApiOptions';

export class ContractsService {

    private readonly config: ApiOptions;

    /**
     * creates a new service
     * @param config the configuration to use
     */
    public constructor(config: ApiOptions) {
        this.config = config;
    }

    /**
     * Get contracts
     * Returns a list of contract accounts.
     * @returns Contract
     * @throws ApiError
     */
    public async get({
        kind,
        creator,
        manager,
        delegate,
        lastActivity,
        typeHash,
        codeHash,
        select,
        sort,
        offset,
        limit = 100,
        includeStorage = false,
    }: {
        /** Contract kind to filter by (`delegator_contract` or `smart_contract`) **/
        kind?: ContractKindParameter | null,
        /** Filters contracts by creator. Allowed fields for `.eqx` mode: `manager`, `delegate`. **/
        creator?: AccountParameter | null,
        /** Filters contracts by manager. Allowed fields for `.eqx` mode: `creator`, `delegate`. **/
        manager?: AccountParameter | null,
        /** Filters contracts by delegate. Allowed fields for `.eqx` mode: `manager`, `creator`. **/
        delegate?: AccountParameter | null,
        /** Filters contracts by last activity level (where the contract was updated) **/
        lastActivity?: Int32Parameter | null,
        /** Filters contracts by 32-bit hash of contract parameter and storage types (helpful for searching similar contracts) **/
        typeHash?: Int32Parameter | null,
        /** Filters contracts by 32-bit hash of contract code (helpful for searching same contracts) **/
        codeHash?: Int32Parameter | null,
        /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
        select?: SelectParameter | null,
        /** Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`. **/
        sort?: SortParameter | null,
        /** Specifies which or how many items should be skipped **/
        offset?: OffsetParameter | null,
        /** Maximum number of items to return **/
        limit?: number,
        /** Specifies whether to include contract storage value in response. **/
        includeStorage?: boolean,
    }): Promise<Array<Contract>> {
        const options = this.getApiRequestOptions({
            kind: kind,
            creator: creator,
            manager: manager,
            delegate: delegate,
            lastActivity: lastActivity,
            typeHash: typeHash,
            codeHash: codeHash,
            select: select,
            sort: sort,
            offset: offset,
            limit: limit,
            includeStorage: includeStorage,
        }
    );
    const result = await __request(options);
    return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contracts
 * Returns a list of contract accounts.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getApiRequestOptions({
    kind,
    creator,
    manager,
    delegate,
    lastActivity,
    typeHash,
    codeHash,
    select,
    sort,
    offset,
    limit = 100,
    includeStorage = false,
}: {
    /** Contract kind to filter by (`delegator_contract` or `smart_contract`) **/
    kind?: ContractKindParameter | null,
    /** Filters contracts by creator. Allowed fields for `.eqx` mode: `manager`, `delegate`. **/
    creator?: AccountParameter | null,
    /** Filters contracts by manager. Allowed fields for `.eqx` mode: `creator`, `delegate`. **/
    manager?: AccountParameter | null,
    /** Filters contracts by delegate. Allowed fields for `.eqx` mode: `manager`, `creator`. **/
    delegate?: AccountParameter | null,
    /** Filters contracts by last activity level (where the contract was updated) **/
    lastActivity?: Int32Parameter | null,
    /** Filters contracts by 32-bit hash of contract parameter and storage types (helpful for searching similar contracts) **/
    typeHash?: Int32Parameter | null,
    /** Filters contracts by 32-bit hash of contract code (helpful for searching same contracts) **/
    codeHash?: Int32Parameter | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
    /** Specifies whether to include contract storage value in response. **/
    includeStorage?: boolean,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts`,
        query: {
            'kind': kind,
            'creator': creator,
            'manager': manager,
            'delegate': delegate,
            'lastActivity': lastActivity,
            'typeHash': typeHash,
            'codeHash': codeHash,
            'select': select,
            'sort': sort,
            'offset': offset,
            'limit': limit,
            'includeStorage': includeStorage,
        },
    };
}

/**
 * Get contracts count
 * Returns a number of contract accounts.
 * @returns number
 * @throws ApiError
 */
public async getCount({
    kind,
}: {
    /** Contract kind to filter by (`delegator_contract` or `smart_contract`) **/
    kind?: ContractKindParameter | null,
}): Promise<number> {
    const options = this.getCountApiRequestOptions({
        kind: kind,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contracts count
 * Returns a number of contract accounts.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getCountApiRequestOptions({
    kind,
}: {
    /** Contract kind to filter by (`delegator_contract` or `smart_contract`) **/
    kind?: ContractKindParameter | null,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/count`,
        query: {
            'kind': kind,
        },
    };
}

/**
 * Get contract by address
 * Returns a contract account with the specified address.
 * @returns Contract
 * @throws ApiError
 */
public async getByAddress({
    address,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
}): Promise<Contract> {
    const options = this.getByAddressApiRequestOptions({
        address: address,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contract by address
 * Returns a contract account with the specified address.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getByAddressApiRequestOptions({
    address,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}`,
    };
}

/**
 * Get same contracts
 * Returns contracts which have the same script as the specified one.
 * Note, contract scripts are compared by 32-bit hash, so in very rare cases there may be collisions.
 * @returns Contract
 * @throws ApiError
 */
public async getSame({
    address,
    select,
    sort,
    offset,
    limit = 100,
    includeStorage = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
    /** Specifies whether to include contract storage value in response. **/
    includeStorage?: boolean,
}): Promise<Array<Contract>> {
    const options = this.getSameApiRequestOptions({
        address: address,
        select: select,
        sort: sort,
        offset: offset,
        limit: limit,
        includeStorage: includeStorage,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get same contracts
 * Returns contracts which have the same script as the specified one.
 * Note, contract scripts are compared by 32-bit hash, so in very rare cases there may be collisions.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getSameApiRequestOptions({
    address,
    select,
    sort,
    offset,
    limit = 100,
    includeStorage = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
    /** Specifies whether to include contract storage value in response. **/
    includeStorage?: boolean,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/same`,
        query: {
            'select': select,
            'sort': sort,
            'offset': offset,
            'limit': limit,
            'includeStorage': includeStorage,
        },
    };
}

/**
 * Get similar contracts
 * Returns contracts which have the same interface (parameter and storage types) as the specified one.
 * Note, contract parameter and storage types are compared by 32-bit hash, so in very rare cases there may be collisions.
 * @returns Contract
 * @throws ApiError
 */
public async getSimilar({
    address,
    select,
    sort,
    offset,
    limit = 100,
    includeStorage = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
    /** Specifies whether to include contract storage value in response. **/
    includeStorage?: boolean,
}): Promise<Array<Contract>> {
    const options = this.getSimilarApiRequestOptions({
        address: address,
        select: select,
        sort: sort,
        offset: offset,
        limit: limit,
        includeStorage: includeStorage,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get similar contracts
 * Returns contracts which have the same interface (parameter and storage types) as the specified one.
 * Note, contract parameter and storage types are compared by 32-bit hash, so in very rare cases there may be collisions.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getSimilarApiRequestOptions({
    address,
    select,
    sort,
    offset,
    limit = 100,
    includeStorage = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
    /** Specifies whether to include contract storage value in response. **/
    includeStorage?: boolean,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/similar`,
        query: {
            'select': select,
            'sort': sort,
            'offset': offset,
            'limit': limit,
            'includeStorage': includeStorage,
        },
    };
}

/**
 * Get contract code
 * Returns a code of the specified contract.
 * @returns any
 * @throws ApiError
 */
public async getCode({
    address,
    format,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Code format (`0` - micheline, `1` - michelson, `2` - bytes (base64)) **/
    format: number,
}): Promise<any> {
    const options = this.getCodeApiRequestOptions({
        address: address,
        format: format,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contract code
 * Returns a code of the specified contract.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getCodeApiRequestOptions({
    address,
    format,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Code format (`0` - micheline, `1` - michelson, `2` - bytes (base64)) **/
    format: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/code`,
        query: {
            'format': format,
        },
    };
}

/**
 * Get JSON Schema [2020-12] interface for the contract
 * Returns standard JSON Schema for contract storage, entrypoints, and Big_map entries.
 * @returns ContractInterface
 * @throws ApiError
 */
public async getInterface({
    address,
}: {
    /** Contract address **/
    address: string | null,
}): Promise<ContractInterface> {
    const options = this.getInterfaceApiRequestOptions({
        address: address,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get JSON Schema [2020-12] interface for the contract
 * Returns standard JSON Schema for contract storage, entrypoints, and Big_map entries.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getInterfaceApiRequestOptions({
    address,
}: {
    /** Contract address **/
    address: string | null,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/interface`,
    };
}

/**
 * Get contract entrypoints
 * Returns entrypoints of the specified contract.
 * @returns Entrypoint
 * @throws ApiError
 */
public async getEntrypoints({
    address,
    all = false,
    json = true,
    micheline = false,
    michelson = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** If true, returns all entrypoints, including unused ones.
     * Unused means that the entrypoint can be normalized to a more specific one.
     * For example here `(or %entry1 (unit %entry2) (nat %entry3))` the `%entry1` is unused entrypoint
     * because it can be normalized to `%entry2` or `%entry3` **/
    all?: boolean,
    /** Include parameters schema in human-readable JSON format **/
    json?: boolean,
    /** Include parameters schema in micheline format **/
    micheline?: boolean,
    /** Include parameters schema in michelson format **/
    michelson?: boolean,
}): Promise<Array<Entrypoint>> {
    const options = this.getEntrypointsApiRequestOptions({
        address: address,
        all: all,
        json: json,
        micheline: micheline,
        michelson: michelson,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contract entrypoints
 * Returns entrypoints of the specified contract.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getEntrypointsApiRequestOptions({
    address,
    all = false,
    json = true,
    micheline = false,
    michelson = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** If true, returns all entrypoints, including unused ones.
     * Unused means that the entrypoint can be normalized to a more specific one.
     * For example here `(or %entry1 (unit %entry2) (nat %entry3))` the `%entry1` is unused entrypoint
     * because it can be normalized to `%entry2` or `%entry3` **/
    all?: boolean,
    /** Include parameters schema in human-readable JSON format **/
    json?: boolean,
    /** Include parameters schema in micheline format **/
    micheline?: boolean,
    /** Include parameters schema in michelson format **/
    michelson?: boolean,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/entrypoints`,
        query: {
            'all': all,
            'json': json,
            'micheline': micheline,
            'michelson': michelson,
        },
    };
}

/**
 * Get entrypoint by name
 * Returns contract's entrypoint with specified name.
 * @returns Entrypoint
 * @throws ApiError
 */
public async getEntrypointByName({
    address,
    name,
    json = true,
    micheline = false,
    michelson = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Entrypoint name **/
    name: string | null,
    /** Include parameters schema in human-readable JSON format **/
    json?: boolean,
    /** Include parameters schema in micheline format **/
    micheline?: boolean,
    /** Include parameters schema in michelson format **/
    michelson?: boolean,
}): Promise<Entrypoint> {
    const options = this.getEntrypointByNameApiRequestOptions({
        address: address,
        name: name,
        json: json,
        micheline: micheline,
        michelson: michelson,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get entrypoint by name
 * Returns contract's entrypoint with specified name.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getEntrypointByNameApiRequestOptions({
    address,
    name,
    json = true,
    micheline = false,
    michelson = false,
}: {
    /** Contract address (starting with KT) **/
    address: string | null,
    /** Entrypoint name **/
    name: string | null,
    /** Include parameters schema in human-readable JSON format **/
    json?: boolean,
    /** Include parameters schema in micheline format **/
    micheline?: boolean,
    /** Include parameters schema in michelson format **/
    michelson?: boolean,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/entrypoints/${name}`,
        query: {
            'json': json,
            'micheline': micheline,
            'michelson': michelson,
        },
    };
}

/**
 * Build entrypoint parameters
 * Returns micheline parameters converted from its JSON representation.
 * @returns any
 * @throws ApiError
 */
public async buildEntrypointParameters({
    address,
    name,
    value,
}: {
    /** Contract address **/
    address: string | null,
    /** Entrypoint name **/
    name: string | null,
    /** Json parameters **/
    value?: string | null,
}): Promise<any> {
    const options = this.buildEntrypointParametersApiRequestOptions({
        address: address,
        name: name,
        value: value,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Build entrypoint parameters
 * Returns micheline parameters converted from its JSON representation.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public buildEntrypointParametersApiRequestOptions({
    address,
    name,
    value,
}: {
    /** Contract address **/
    address: string | null,
    /** Entrypoint name **/
    name: string | null,
    /** Json parameters **/
    value?: string | null,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/entrypoints/${name}/build`,
        query: {
            'value': value,
        },
    };
}

/**
 * Build entrypoint parameters
 * Returns micheline parameters converted from its JSON representation.
 * @returns any
 * @throws ApiError
 */
public async buildEntrypointParameters2({
    address,
    name,
    requestBody,
}: {
    /** Contract address **/
    address: string | null,
    /** Entrypoint name **/
    name: string | null,
    /** Json parameters **/
    requestBody: any,
}): Promise<any> {
    const options = this.buildEntrypointParameters2ApiRequestOptions({
        address: address,
        name: name,
        requestBody: requestBody,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Build entrypoint parameters
 * Returns micheline parameters converted from its JSON representation.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public buildEntrypointParameters2ApiRequestOptions({
    address,
    name,
    requestBody,
}: {
    /** Contract address **/
    address: string | null,
    /** Entrypoint name **/
    name: string | null,
    /** Json parameters **/
    requestBody: any,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'POST',
        path: `/v1/contracts/${address}/entrypoints/${name}/build`,
        body: requestBody,
        mediaType: 'application/json',
    };
}

/**
 * Get contract storage
 * Returns contract storage value in JSON format.
 * @returns any
 * @throws ApiError
 */
public async getStorage({
    address,
    level,
    path,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage value should be taken. If `0` or not specified, the current value will be returned. **/
    level: number,
    /** Path in the JSON value (point-separated list of field names, e.g. `path=settings.refund_time` to return **/
    path?: string | null,
}): Promise<any> {
    const options = this.getStorageApiRequestOptions({
        address: address,
        level: level,
        path: path,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contract storage
 * Returns contract storage value in JSON format.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getStorageApiRequestOptions({
    address,
    level,
    path,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage value should be taken. If `0` or not specified, the current value will be returned. **/
    level: number,
    /** Path in the JSON value (point-separated list of field names, e.g. `path=settings.refund_time` to return **/
    path?: string | null,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/storage`,
        query: {
            'level': level,
            'path': path,
        },
    };
}

/**
 * Get contract storage schema
 * Returns JSON schema of the contract storage.
 * @returns any
 * @throws ApiError
 */
public async getStorageSchema({
    address,
    level,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned. **/
    level: number,
}): Promise<any> {
    const options = this.getStorageSchemaApiRequestOptions({
        address: address,
        level: level,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contract storage schema
 * Returns JSON schema of the contract storage.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getStorageSchemaApiRequestOptions({
    address,
    level,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned. **/
    level: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/storage/schema`,
        query: {
            'level': level,
        },
    };
}

/**
 * Get contract storage history
 * Returns contract storage historical values.
 * @returns StorageRecord
 * @throws ApiError
 */
public async getStorageHistory({
    address,
    lastId,
    limit = 10,
}: {
    /** Contract address **/
    address: string | null,
    /** Id of the last item received (for pagination) **/
    lastId: number,
    /** Maximum number of items to return **/
    limit?: number,
}): Promise<Array<StorageRecord>> {
    const options = this.getStorageHistoryApiRequestOptions({
        address: address,
        lastId: lastId,
        limit: limit,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contract storage history
 * Returns contract storage historical values.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getStorageHistoryApiRequestOptions({
    address,
    lastId,
    limit = 10,
}: {
    /** Contract address **/
    address: string | null,
    /** Id of the last item received (for pagination) **/
    lastId: number,
    /** Maximum number of items to return **/
    limit?: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/storage/history`,
        query: {
            'lastId': lastId,
            'limit': limit,
        },
    };
}

/**
 * Get raw contract storage
 * Returns raw contract storage value in micheline format.
 * @returns IMicheline
 * @throws ApiError
 */
public async getRawStorage({
    address,
    level,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage value should be taken. If `0` or not specified, the current value will be returned. **/
    level: number,
}): Promise<IMicheline> {
    const options = this.getRawStorageApiRequestOptions({
        address: address,
        level: level,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get raw contract storage
 * Returns raw contract storage value in micheline format.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getRawStorageApiRequestOptions({
    address,
    level,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage value should be taken. If `0` or not specified, the current value will be returned. **/
    level: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/storage/raw`,
        query: {
            'level': level,
        },
    };
}

/**
 * Get raw contract storage schema
 * Returns micheline schema (type) of the contract storage.
 * @returns IMicheline
 * @throws ApiError
 */
public async getRawStorageSchema({
    address,
    level,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned. **/
    level: number,
}): Promise<IMicheline> {
    const options = this.getRawStorageSchemaApiRequestOptions({
        address: address,
        level: level,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get raw contract storage schema
 * Returns micheline schema (type) of the contract storage.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getRawStorageSchemaApiRequestOptions({
    address,
    level,
}: {
    /** Contract address **/
    address: string | null,
    /** Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned. **/
    level: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/storage/raw/schema`,
        query: {
            'level': level,
        },
    };
}

/**
 * Get raw contract storage history
 * Returns raw contract storage historical values.
 * @returns StorageRecord
 * @throws ApiError
 */
public async getRawStorageHistory({
    address,
    lastId,
    limit = 10,
}: {
    /** Contract address **/
    address: string | null,
    /** Id of the last item received (for pagination) **/
    lastId: number,
    /** Maximum number of items to return **/
    limit?: number,
}): Promise<Array<StorageRecord>> {
    const options = this.getRawStorageHistoryApiRequestOptions({
        address: address,
        lastId: lastId,
        limit: limit,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get raw contract storage history
 * Returns raw contract storage historical values.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getRawStorageHistoryApiRequestOptions({
    address,
    lastId,
    limit = 10,
}: {
    /** Contract address **/
    address: string | null,
    /** Id of the last item received (for pagination) **/
    lastId: number,
    /** Maximum number of items to return **/
    limit?: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/storage/raw/history`,
        query: {
            'lastId': lastId,
            'limit': limit,
        },
    };
}

/**
 * Get contract bigmaps
 * Returns all active bigmaps allocated in the contract storage.
 * @returns BigMap
 * @throws ApiError
 */
public async getBigMaps({
    address,
    micheline,
    tags,
    select,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Filters bigmaps tags (`token_metadata` - tzip-12, `metadata` - tzip-16). **/
    tags?: BigMapTagsParameter | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object.
     * If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts bigmaps by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): Promise<Array<BigMap>> {
    const options = this.getBigMapsApiRequestOptions({
        address: address,
        micheline: micheline,
        tags: tags,
        select: select,
        sort: sort,
        offset: offset,
        limit: limit,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get contract bigmaps
 * Returns all active bigmaps allocated in the contract storage.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getBigMapsApiRequestOptions({
    address,
    micheline,
    tags,
    select,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Filters bigmaps tags (`token_metadata` - tzip-12, `metadata` - tzip-16). **/
    tags?: BigMapTagsParameter | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object.
     * If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts bigmaps by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/bigmaps`,
        query: {
            'micheline': micheline,
            'tags': tags,
            'select': select,
            'sort': sort,
            'offset': offset,
            'limit': limit,
        },
    };
}

/**
 * Get bigmap by name
 * Returns contract bigmap with the specified name or storage path.
 * @returns BigMap
 * @throws ApiError
 */
public async getBigMapByName({
    address,
    name,
    micheline,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
}): Promise<BigMap> {
    const options = this.getBigMapByNameApiRequestOptions({
        address: address,
        name: name,
        micheline: micheline,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get bigmap by name
 * Returns contract bigmap with the specified name or storage path.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getBigMapByNameApiRequestOptions({
    address,
    name,
    micheline,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/bigmaps/${name}`,
        query: {
            'micheline': micheline,
        },
    };
}

/**
 * Get bigmap keys
 * Returns keys of a contract bigmap with the specified name.
 * @returns BigMapKey
 * @throws ApiError
 */
public async getBigMapByNameKeys({
    address,
    name,
    micheline,
    active,
    key,
    value,
    lastLevel,
    select,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Filters keys by status: `true` - active, `false` - removed. **/
    active?: boolean | null,
    /** Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`. **/
    key?: JsonParameter | null,
    /** Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`. **/
    value?: JsonParameter | null,
    /** Filters bigmap keys by the last update level. **/
    lastLevel?: Int32Parameter | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts bigmap keys by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `updates`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): Promise<Array<BigMapKey>> {
    const options = this.getBigMapByNameKeysApiRequestOptions({
        address: address,
        name: name,
        micheline: micheline,
        active: active,
        key: key,
        value: value,
        lastLevel: lastLevel,
        select: select,
        sort: sort,
        offset: offset,
        limit: limit,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get bigmap keys
 * Returns keys of a contract bigmap with the specified name.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getBigMapByNameKeysApiRequestOptions({
    address,
    name,
    micheline,
    active,
    key,
    value,
    lastLevel,
    select,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Filters keys by status: `true` - active, `false` - removed. **/
    active?: boolean | null,
    /** Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`. **/
    key?: JsonParameter | null,
    /** Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`. **/
    value?: JsonParameter | null,
    /** Filters bigmap keys by the last update level. **/
    lastLevel?: Int32Parameter | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts bigmap keys by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `updates`. **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/bigmaps/${name}/keys`,
        query: {
            'micheline': micheline,
            'active': active,
            'key': key,
            'value': value,
            'lastLevel': lastLevel,
            'select': select,
            'sort': sort,
            'offset': offset,
            'limit': limit,
        },
    };
}

/**
 * Get bigmap key
 * Returns the specified bigmap key.
 * @returns BigMapKey
 * @throws ApiError
 */
public async getKey({
    address,
    name,
    key,
    micheline,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Either a key hash (`expr123...`) or a plain value (`abcde...`).
     * Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{"address":"tz123","token":123}`. **/
    key: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
}): Promise<BigMapKey> {
    const options = this.getKeyApiRequestOptions({
        address: address,
        name: name,
        key: key,
        micheline: micheline,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get bigmap key
 * Returns the specified bigmap key.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getKeyApiRequestOptions({
    address,
    name,
    key,
    micheline,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Either a key hash (`expr123...`) or a plain value (`abcde...`).
     * Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{"address":"tz123","token":123}`. **/
    key: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/bigmaps/${name}/keys/${key}`,
        query: {
            'micheline': micheline,
        },
    };
}

/**
 * Get bigmap key updates
 * Returns updates history for the specified bigmap key.
 * @returns BigMapKeyUpdate
 * @throws ApiError
 */
public async getKeyUpdates({
    address,
    name,
    key,
    micheline,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Either a key hash (`expr123...`) or a plain value (`abcde...`).
     * Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{"address":"tz123","token":123}`. **/
    key: string | null,
    /** Format of the key value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Sorts bigmap updates by specified field. Supported fields: `id` (default). **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): Promise<Array<BigMapKeyUpdate>> {
    const options = this.getKeyUpdatesApiRequestOptions({
        address: address,
        name: name,
        key: key,
        micheline: micheline,
        sort: sort,
        offset: offset,
        limit: limit,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get bigmap key updates
 * Returns updates history for the specified bigmap key.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getKeyUpdatesApiRequestOptions({
    address,
    name,
    key,
    micheline,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Either a key hash (`expr123...`) or a plain value (`abcde...`).
     * Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{"address":"tz123","token":123}`. **/
    key: string | null,
    /** Format of the key value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Sorts bigmap updates by specified field. Supported fields: `id` (default). **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/bigmaps/${name}/keys/${key}/updates`,
        query: {
            'micheline': micheline,
            'sort': sort,
            'offset': offset,
            'limit': limit,
        },
    };
}

/**
 * Get historical keys
 * Returns a list of bigmap keys at the specific block.
 * @returns BigMapKeyHistorical
 * @throws ApiError
 */
public async getHistoricalKeys({
    address,
    name,
    level,
    micheline,
    active,
    key,
    value,
    select,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Level of the block at which you want to get bigmap keys **/
    level: number,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Filters keys by status: `true` - active, `false` - removed. **/
    active?: boolean | null,
    /** Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`. **/
    key?: JsonParameter | null,
    /** Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`. **/
    value?: JsonParameter | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts bigmap keys by specified field. Supported fields: `id` (default). **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): Promise<Array<BigMapKeyHistorical>> {
    const options = this.getHistoricalKeysApiRequestOptions({
        address: address,
        name: name,
        level: level,
        micheline: micheline,
        active: active,
        key: key,
        value: value,
        select: select,
        sort: sort,
        offset: offset,
        limit: limit,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get historical keys
 * Returns a list of bigmap keys at the specific block.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getHistoricalKeysApiRequestOptions({
    address,
    name,
    level,
    micheline,
    active,
    key,
    value,
    select,
    sort,
    offset,
    limit = 100,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Level of the block at which you want to get bigmap keys **/
    level: number,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
    /** Filters keys by status: `true` - active, `false` - removed. **/
    active?: boolean | null,
    /** Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`. **/
    key?: JsonParameter | null,
    /** Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,
     * so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`. **/
    value?: JsonParameter | null,
    /** Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes. **/
    select?: SelectParameter | null,
    /** Sorts bigmap keys by specified field. Supported fields: `id` (default). **/
    sort?: SortParameter | null,
    /** Specifies which or how many items should be skipped **/
    offset?: OffsetParameter | null,
    /** Maximum number of items to return **/
    limit?: number,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/bigmaps/${name}/historical_keys/${level}`,
        query: {
            'micheline': micheline,
            'active': active,
            'key': key,
            'value': value,
            'select': select,
            'sort': sort,
            'offset': offset,
            'limit': limit,
        },
    };
}

/**
 * Get historical key
 * Returns the specified bigmap key at the specific block.
 * @returns BigMapKeyHistorical
 * @throws ApiError
 */
public async getKey2({
    address,
    name,
    level,
    key,
    micheline,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Level of the block at which you want to get bigmap key **/
    level: number,
    /** Either a key hash (`expr123...`) or a plain value (`abcde...`).
     * Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{"address":"tz123","token":123}`. **/
    key: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
}): Promise<BigMapKeyHistorical> {
    const options = this.getKey2ApiRequestOptions({
        address: address,
        name: name,
        level: level,
        key: key,
        micheline: micheline,
    }
);
const result = await __request(options);
return result.body;
}

/**
 * **used to get the request options without making a http request**
 * Get historical key
 * Returns the specified bigmap key at the specific block.
 * @returns ApiRequestOptions the request options to fulfill a http request
 * @throws ApiError
 */
public getKey2ApiRequestOptions({
    address,
    name,
    level,
    key,
    micheline,
}: {
    /** Contract address **/
    address: string | null,
    /** Bigmap name is the last piece of the bigmap storage path.
     * For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.
     * If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. **/
    name: string | null,
    /** Level of the block at which you want to get bigmap key **/
    level: number,
    /** Either a key hash (`expr123...`) or a plain value (`abcde...`).
     * Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{"address":"tz123","token":123}`. **/
    key: string | null,
    /** Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string **/
    micheline: MichelineFormat,
}): ApiRequestOptions {
    return {
        ...this.config,
        method: 'GET',
        path: `/v1/contracts/${address}/bigmaps/${name}/historical_keys/${level}/${key}`,
        query: {
            'micheline': micheline,
        },
    };
}

}