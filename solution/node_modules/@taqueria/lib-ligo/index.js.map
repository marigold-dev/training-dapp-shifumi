{"version":3,"sources":["index.ts","createContract.ts","ligo_templates.ts","main.ts","common.ts","compile.ts","compile-all.ts","ligo.ts","test.ts"],"sourcesContent":["import { Option, Plugin, PositionalArg, Task, Template } from '@taqueria/node-sdk';\nimport * as PluginSchema from '@taqueria/protocol/PluginSchema';\n\nimport createContract from './createContract';\nimport main from './main';\n\ntype PluginConfigurator = (plugin: PluginSchema.RawPluginSchema) => PluginSchema.RawPluginSchema;\ntype ConfiguratorArgs = {\n\tname: string;\n\talias: string;\n\tconfigurator?: PluginConfigurator;\n\tunparsedArgs: string[];\n\tdockerImage: string;\n\tdockerImageEnvVar: string;\n\tcanUseLIGOBinary: boolean;\n\ttemplates?: Record<string, string>;\n};\n\nexport const configurePlugin = (settings: ConfiguratorArgs) => {\n\tconst schema = {\n\t\tname: settings.name,\n\t\tschema: '1.0',\n\t\tversion: '0.1',\n\t\talias: settings.alias,\n\t\ttasks: [\n\t\t\tTask.create({\n\t\t\t\ttask: 'ligo',\n\t\t\t\tcommand: 'ligo',\n\t\t\t\tdescription:\n\t\t\t\t\t'This task allows you to run arbitrary LIGO native commands. Note that they might not benefit from the abstractions provided by Taqueria',\n\t\t\t\toptions: [\n\t\t\t\t\tOption.create({\n\t\t\t\t\t\tshortFlag: 'c',\n\t\t\t\t\t\tflag: 'command',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: 'The command to be passed to the underlying LIGO binary, wrapped in quotes',\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\thandler: 'proxy',\n\t\t\t\tencoding: 'none',\n\t\t\t}),\n\t\t\tTask.create({\n\t\t\t\ttask: 'compile',\n\t\t\t\tcommand: 'compile <sourceFile>',\n\t\t\t\taliases: ['c', 'compile-ligo'],\n\t\t\t\tdescription:\n\t\t\t\t\t'Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storage/parameter list files if they are found',\n\t\t\t\toptions: [\n\t\t\t\t\tOption.create({\n\t\t\t\t\t\tflag: 'json',\n\t\t\t\t\t\tboolean: true,\n\t\t\t\t\t\tdescription: 'Emit JSON-encoded Michelson',\n\t\t\t\t\t}),\n\t\t\t\t\tOption.create({\n\t\t\t\t\t\tflag: 'module',\n\t\t\t\t\t\tshortFlag: 'm',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: 'The LIGO module to be compiled',\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\thandler: 'proxy',\n\t\t\t\tencoding: 'json',\n\t\t\t}),\n\t\t\tTask.create({\n\t\t\t\ttask: 'compile-all',\n\t\t\t\tcommand: 'compile-all',\n\t\t\t\tdescription:\n\t\t\t\t\t'Compile all main smart contracts written in a LIGO syntax to Michelson code, along with their associated storage/parameter list files if they are found',\n\t\t\t\toptions: [\n\t\t\t\t\tOption.create({\n\t\t\t\t\t\tflag: 'json',\n\t\t\t\t\t\tboolean: true,\n\t\t\t\t\t\tdescription: 'Emit JSON-encoded Michelson',\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\thandler: 'proxy',\n\t\t\t\tencoding: 'json',\n\t\t\t}),\n\t\t\tTask.create({\n\t\t\t\ttask: 'test',\n\t\t\t\tcommand: 'test <sourceFile>',\n\t\t\t\tdescription: 'Test a smart contract written in LIGO',\n\t\t\t\thandler: 'proxy',\n\t\t\t\tencoding: 'json',\n\t\t\t}),\n\t\t\tTask.create({\n\t\t\t\ttask: 'get-image',\n\t\t\t\tcommand: 'get-image',\n\t\t\t\tdescription: 'Gets the name of the image to be used',\n\t\t\t\thandler: 'proxy',\n\t\t\t\thidden: true,\n\t\t\t}),\n\t\t],\n\t\ttemplates: [\n\t\t\tTemplate.create({\n\t\t\t\ttemplate: 'contract',\n\t\t\t\tcommand: 'contract <sourceFileName>',\n\t\t\t\tdescription: 'Create a LIGO contract with boilerplate code',\n\t\t\t\tpositionals: [\n\t\t\t\t\tPositionalArg.create({\n\t\t\t\t\t\tplaceholder: 'sourceFileName',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: 'The name of the LIGO contract to generate',\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\toptions: [\n\t\t\t\t\tOption.create({\n\t\t\t\t\t\tshortFlag: 's',\n\t\t\t\t\t\tflag: 'syntax',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: 'The syntax used in the contract',\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\thandler: createContract(settings.templates),\n\t\t\t}),\n\t\t],\n\t\tproxy: main(settings.dockerImage, settings.dockerImageEnvVar, settings.canUseLIGOBinary),\n\t\tpostInstall: `node ${__dirname}/postinstall.js`,\n\t};\n\n\treturn Plugin.create(() => settings.configurator ? settings.configurator(schema) : schema, settings.unparsedArgs);\n};\n","import { sendAsyncErr } from '@taqueria/node-sdk';\nimport { RequestArgs } from '@taqueria/node-sdk';\nimport { writeFile } from 'fs/promises';\nimport * as default_templates from './ligo_templates';\n\ninterface Opts extends RequestArgs.t {\n\tsourceFileName?: string;\n\tsyntax?: string;\n}\n\nconst getLigoTemplate = async (\n\tcontractName: string,\n\tsyntax: string | undefined,\n\ttemplateOverrides?: Record<string, string>,\n): Promise<string> => {\n\tconst matchResult = contractName.match(/\\.[^.]+$/);\n\tconst ext = matchResult ? matchResult[0].substring(1) : null;\n\tconst templates = templateOverrides ?? default_templates;\n\n\tif (syntax === 'mligo') return templates.mligo_template;\n\tif (syntax === 'jsligo') return templates.jsligo_template;\n\n\tif (syntax === undefined) {\n\t\tif (ext === 'mligo') return templates.mligo_template;\n\t\tif (ext === 'jsligo') return templates.jsligo_template;\n\t\treturn sendAsyncErr(\n\t\t\t`Unable to infer LIGO syntax from \"${contractName}\". Please specify a LIGO syntax via the --syntax option`,\n\t\t);\n\t} else {\n\t\treturn sendAsyncErr(`\"${syntax}\" is not a valid syntax. Please specify a valid LIGO syntax`);\n\t}\n};\n\nconst createContract = (templates?: Record<string, string>) => (args: RequestArgs.t) => {\n\tconst unsafeOpts = args as unknown as Opts;\n\tconst contractName = unsafeOpts.sourceFileName as string;\n\tconst syntax = unsafeOpts.syntax;\n\tconst contractsDir = `${args.config.projectDir}/${args.config.contractsDir}`;\n\treturn getLigoTemplate(contractName, syntax, templates)\n\t\t.then(ligo_template => writeFile(`${contractsDir}/${contractName}`, ligo_template));\n};\n\nexport default createContract;\n","export const mligo_template = `\ntype storage = int\ntype return = operation list * storage\n\n(* Three entrypoints *)\n[@entry] let increment (delta : int) (store : storage) : return =\n  [], store + delta\n[@entry] let decrement (delta : int) (store : storage) : return =\n  [], store - delta\n[@entry] let reset (() : unit) (_ : storage) : return =\n  [], 0\n`;\n\nexport const jsligo_template = `\ntype storage = int;\ntype ret = [list<operation>, storage];\n\n// Three entrypoints\n\n// @entry\nconst increment = (delta : int, store : storage) : ret =>\n  [list([]), store + delta];\n\n// @entry\nconst decrement = (delta : int, store : storage) : ret =>\n  [list([]), store - delta];\n\n// @entry\nconst reset = (_ : unit, _ : storage) : ret =>\n  [list([]), 0];\n`;\n","import { RequestArgs, sendAsyncErr, sendAsyncRes } from '@taqueria/node-sdk';\nimport { configure, IntersectionOpts as Opts } from './common';\nimport compile from './compile';\nimport compileAll from './compile-all';\nimport ligo from './ligo';\nimport test from './test';\n\nconst main =\n\t(dockerImage: string, dockerImageEnvVar: string, canUseLIGOBinary: boolean) =>\n\t(parsedArgs: RequestArgs.t): Promise<void> => {\n\t\tconst commonObj = configure(dockerImage, dockerImageEnvVar, canUseLIGOBinary);\n\t\tconst unsafeOpts = parsedArgs as unknown as Opts;\n\t\tswitch (unsafeOpts.task) {\n\t\t\tcase 'ligo':\n\t\t\t\treturn ligo(commonObj, unsafeOpts);\n\t\t\tcase 'compile':\n\t\t\t\treturn compile(commonObj, unsafeOpts);\n\t\t\tcase 'compile-all':\n\t\t\t\treturn compileAll(commonObj, unsafeOpts);\n\t\t\tcase 'test':\n\t\t\t\treturn test(commonObj, parsedArgs);\n\t\t\tcase 'get-image':\n\t\t\t\treturn sendAsyncRes(commonObj.getLigoDockerImage());\n\t\t\tdefault:\n\t\t\t\treturn sendAsyncErr(`${unsafeOpts.task} is not an understood task by the LIGO plugin`);\n\t\t}\n\t};\n\nexport default main;\n","import { getDockerImage, sendErr } from '@taqueria/node-sdk';\nimport { ProxyTaskArgs, RequestArgs } from '@taqueria/node-sdk/types';\nimport * as fs from 'fs';\nimport { delimiter, join } from 'path';\n\nexport interface LigoOpts extends ProxyTaskArgs.t {\n\tcommand: string;\n}\n\nexport interface CompileOpts extends ProxyTaskArgs.t {\n\tsourceFile: string;\n\tjson: boolean;\n\tmodule?: string;\n}\n\nexport interface CompileAllOpts extends ProxyTaskArgs.t {\n\tjson: boolean;\n}\n\nexport interface TestOpts extends RequestArgs.t {\n\ttask?: string;\n\tsourceFile?: string;\n}\n\nexport type IntersectionOpts =\n\t& LigoOpts\n\t& CompileOpts\n\t& CompileAllOpts\n\t& TestOpts;\n\nexport type UnionOpts = LigoOpts | CompileOpts | CompileAllOpts | TestOpts;\n\nexport const getInputFilenameAbsPath = (\n\tparsedArgs: UnionOpts,\n\tsourceFile: string,\n): string =>\n\tjoin(\n\t\tparsedArgs.config.projectDir,\n\t\tparsedArgs.config.contractsDir ?? 'contracts',\n\t\tsourceFile,\n\t);\n\nexport const getInputFilenameRelPath = (\n\tparsedArgs: UnionOpts,\n\tsourceFile: string,\n): string => join(parsedArgs.config.contractsDir ?? 'contracts', sourceFile);\n\nexport const formatLigoError = (err: Error): Error => {\n\tlet result = err.message.replace(/Command failed.+?\\n/, '');\n\tif (\n\t\tresult.includes(\n\t\t\t'An internal error ocurred. Please, contact the developers.',\n\t\t)\n\t\t&& result.includes('Module Contract not found with last Contract.')\n\t) {\n\t\tresult =\n\t\t\t`By convention, Taqueria expects you to import your contract with Contract as the module name.\\nFor instance, if you have a contract in a file called \"increment.mligo\", in your parameter/storage list file you must include #import \"Increment.mligo\" \"Contract\" for compilation to be successful.`;\n\t} else {\n\t\tconst regex = /contracts\\/(.+): No such file or directory/;\n\t\tconst match = regex.exec(result);\n\t\tif (match) {\n\t\t\tconst filename = match[1];\n\t\t\tresult =\n\t\t\t\t`The file ${filename} was not found. Please ensure that the file exists and that it is in the contracts directory.`;\n\t\t}\n\t}\n\n\terr.message = result\n\t\t.replace(\n\t\t\t'An internal error ocurred. Please, contact the developers.',\n\t\t\t'The LIGO compiler experienced an internal error. Please contact the LIGO developers.',\n\t\t)\n\t\t.replace(\n\t\t\t/Module (\"Contract\\.[^\"]+\") not found/,\n\t\t\t'The module $1 was not found. If your contract is defined within a namespace, please ensure that it has been exported.',\n\t\t);\n\n\treturn err;\n};\n\nexport const emitExternalError = (\n\terrs: unknown[] | unknown,\n\tsourceFile: string,\n): void => {\n\tsendErr(`\\n=== Error messages for ${sourceFile} ===`);\n\tconst errors = Array.isArray(errs) ? errs : [errs];\n\terrors.map(err => {\n\t\terr instanceof Error ? sendErr(err.message) : sendErr(err as any);\n\t});\n\tsendErr(`===`);\n};\n\nexport const configure = (dockerImage: string, dockerImageEnvVar: string, canUseLIGOBinary: boolean) => ({\n\tLIGO_DEFAULT_IMAGE: dockerImage,\n\tLIGO_IMAGE_ENV_VAR: dockerImageEnvVar,\n\tgetLigoDockerImage: () => getDockerImage(dockerImage, dockerImageEnvVar),\n\tbaseDriverCmd: (projectDir: string) => baseDriverCmd(projectDir, dockerImage, canUseLIGOBinary),\n});\n\nexport type Common = ReturnType<typeof configure>;\nfunction exists(path: string): boolean {\n\ttry {\n\t\tfs.accessSync(path, fs.constants.X_OK);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nfunction getLigoBinaryFromPath() {\n\tconst { PATH } = process.env;\n\tif (!PATH) {\n\t\treturn null;\n\t}\n\tconst paths = PATH.split(delimiter);\n\tfor (const candidatePath of paths) {\n\t\tconst possibleLigoPath = join(candidatePath, 'ligo');\n\t\tif (exists(possibleLigoPath)) {\n\t\t\treturn possibleLigoPath;\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction baseDriverCmd(\n\tprojectDir: string,\n\tligoDockerImage: string,\n\tcanUseLIGOBinary: boolean,\n): string {\n\tconst ligoBinaryFromPath = canUseLIGOBinary ? getLigoBinaryFromPath() : null;\n\tif (ligoBinaryFromPath !== null) {\n\t\treturn ligoBinaryFromPath;\n\t} else {\n\t\treturn `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ${ligoDockerImage}`;\n\t}\n}\n","import {\n\texecCmd,\n\tgetArch,\n\tgetArtifactsDir,\n\tsendAsyncErr,\n\tsendErr,\n\tsendJsonRes,\n\tsendRes,\n\tsendWarn,\n} from '@taqueria/node-sdk';\nimport { createReadStream } from 'fs';\nimport { access, readFile, writeFile } from 'fs/promises';\nimport { basename, extname, join } from 'path';\nimport * as readline from 'readline';\nimport {\n\tCommon,\n\tCompileOpts as Opts,\n\temitExternalError,\n\tformatLigoError,\n\tgetInputFilenameAbsPath,\n\tgetInputFilenameRelPath,\n\tUnionOpts,\n} from './common';\n\nexport type TableRow = { source: string; artifact: string; err?: unknown };\n\nexport type ExprKind = 'storage' | 'default_storage' | 'parameter';\n\nexport type Syntax = 'mligo' | 'jsligo' | 'religo' | 'ligo';\n\nexport type ModuleInfo = {\n\tmoduleName: string;\n\tsourceName: string;\n\tsourceFile: string;\n\tsyntax: Syntax;\n\ttype: 'file-main' | 'file-entry' | 'module-main' | 'module-entry';\n};\n\nconst COMPILE_ERR_MSG: string = 'Not compiled';\n\nconst isStorageKind = (exprKind: ExprKind): boolean => exprKind === 'storage' || exprKind === 'default_storage';\n\nexport const isSupportedLigoSyntax = (sourceFile: string) => /\\.(mligo|jsligo)$/.test(sourceFile);\n\nexport const isUnsupportedLigoSyntax = (sourceFile: string) => /\\.(ligo|religo)$/.test(sourceFile);\n\nexport const isLIGOFile = (sourceFile: string) =>\n\tisSupportedLigoSyntax(sourceFile) || isUnsupportedLigoSyntax(sourceFile);\n\nexport const isStorageListFile = (sourceFile: string): boolean =>\n\t/.+\\.(storageList|storages)\\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);\n\nexport const isParameterListFile = (sourceFile: string): boolean =>\n\t/.+\\.(parameterList|parameters)\\.(ligo|religo|mligo|jsligo)$/.test(\n\t\tsourceFile,\n\t);\n\nconst extractExt = (path: string): string => {\n\tconst matchResult = path.match(/\\.(ligo|religo|mligo|jsligo)$/);\n\treturn matchResult ? matchResult[0] : '';\n};\n\nconst removeExt = (path: string): string => {\n\tconst extRegex = new RegExp(extractExt(path));\n\treturn path.replace(extRegex, '');\n};\n\nconst isOutputFormatJSON = (parsedArgs: Opts): boolean => parsedArgs.json;\n\nconst getOutputContractFilename = (\n\tparsedArgs: Opts,\n\tmodule: ModuleInfo,\n): string => {\n\tconst ext = isOutputFormatJSON(parsedArgs) ? '.json' : '.tz';\n\treturn join(getArtifactsDir(parsedArgs), `${module.moduleName}${ext}`);\n};\n\nconst getOutputExprFilename = (\n\tparsedArgs: Opts,\n\tmodule: ModuleInfo,\n\texprKind: ExprKind,\n\texprName: string,\n): string => {\n\tconst contractName = module.moduleName;\n\tconst ext = isOutputFormatJSON(parsedArgs) ? '.json' : '.tz';\n\tconst outputFile = exprKind === 'default_storage'\n\t\t? `${contractName}.default_storage${ext}`\n\t\t: `${contractName}.${exprKind}.${exprName}${ext}`;\n\treturn join(getArtifactsDir(parsedArgs), `${outputFile}`);\n};\n\nconst getExprNames = (\n\tparsedArgs: Opts,\n\tsourceFile: string,\n): Promise<string[]> => {\n\treturn new Promise((resolve, reject) => {\n\t\tconst inputFilePath = getInputFilenameAbsPath(parsedArgs, sourceFile);\n\t\tconst readInterface = readline.createInterface({\n\t\t\tinput: createReadStream(inputFilePath),\n\t\t\toutput: process.stdout,\n\t\t});\n\n\t\tconst variableNames: string[] = [];\n\n\t\treadInterface.on('line', function(line) {\n\t\t\t// Skip lines that start with a comment\n\t\t\tif (!line.trim().startsWith('//')) {\n\t\t\t\tconst matches = line.match(/(?<=\\s*(let|const)\\s+)[a-zA-Z0-9_]+/g);\n\t\t\t\tif (matches) {\n\t\t\t\t\tvariableNames.push(...matches);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treadInterface.on('close', function() {\n\t\t\tresolve(variableNames);\n\t\t});\n\t});\n};\n\n// Helper function to get the initial message based on the pair value\nconst getInitialMessage = (pair: string, module: ModuleInfo) => {\n\tconst messages = {\n\t\t'mligo-file-main':\n\t\t\t`// When this file was created, the smart contract was defined with a main function that was not within a named module. As such, the examples below are written with that assumption in mind.`,\n\t\t'mligo-file-entry':\n\t\t\t`// When this file was created, the smart contract was defined with an entrypoint using \\`@entry\\` that was not within a named module. As such, the examples below are written with that assumption in mind.`,\n\t\t'mligo-module-main':\n\t\t\t`// When this file was created, the smart contract was defined with a main function that was within a named module. As such, the examples below are written with that assumption in mind.`,\n\t\t'mligo-module-entry':\n\t\t\t`// When this file was created, the smart contract was defined with an entrypoint using \\`@entry\\` that was within a named module. As such, the examples below are written with that assumption in mind.`,\n\t\t'jsligo-file-main':\n\t\t\t`// When this file was created, the smart contract was defined with a main function that was not within a namespace. As such, the examples below are written with that assumption in mind.\\n`\n\t\t\t+ `// NOTE: The \"storage\" type should be exported from the contract file (${module.sourceFile})`,\n\t\t'jsligo-file-entry':\n\t\t\t`// When this file was created, the smart contract was defined with an entrypoint using \\`@entry\\` that was not within a namespace. As such, the examples below are written with that assumption in mind.`,\n\t\t'jsligo-module-main':\n\t\t\t`// When this file was created, the smart contract was defined with a main function that was within a namespace. As such, the examples below are written with that assumption in mind.\\n`\n\t\t\t+ `// NOTE: The \"storage\" type should be exported from the contract file (${module.sourceFile})`,\n\t\t'jsligo-module-entry':\n\t\t\t`// When this file was created, the smart contract was defined with an entrypoint using \\`@entry\\` that was within a namespace. As such, the examples below are written with that assumption in mind.`,\n\t\t// ... any other combinations\n\t} as Record<string, string>;\n\n\treturn messages[pair] || '// This file was created by Taqueria.';\n};\n\n// Helper function to get a common message\nconst getCommonMsg = (langType: Syntax, listType: ExprKind) => {\n\tconst varKeyword = langType === 'mligo' ? 'let' : 'const';\n\tconst commonMsgForStorage = `// IMPORTANT: We suggest always explicitly typing your storage values:\\n`\n\t\t+ `// E.g.: \\`${varKeyword} storage: int = 10\\` or \\`${varKeyword} storage: Contract.storage = 10\\``;\n\n\tconst commonMsgForParameter = `// IMPORTANT: We suggest always explicitly typing your parameter values:\\n`\n\t\t+ `// E.g.: \\`${varKeyword} parameter: int = 10\\` or \\`${varKeyword} parameter: Contract.parameter = 10\\``;\n\n\treturn listType === 'storage' ? commonMsgForStorage : commonMsgForParameter;\n};\n\n// Main function to get the content for storage or parameter\nconst getContent = (moduleInfo: ModuleInfo, listType: ExprKind) => {\n\tconst linkToContract = `#import \"${moduleInfo.sourceFile}\" \"Contract\"`;\n\tconst pair = `${moduleInfo.syntax}-${moduleInfo.type}`;\n\tconst initialMsg = getInitialMessage(pair, moduleInfo);\n\tconst commonMsg = getCommonMsg(moduleInfo.syntax, listType);\n\n\treturn `${linkToContract}\\n\\n${initialMsg}\\n\\n${commonMsg}`;\n};\n\n// Usage for storage list\nconst initContentForStorage = (moduleInfo: ModuleInfo) => getContent(moduleInfo, 'storage');\n\n// Usage for parameter list\nconst initContentForParameter = (moduleInfo: ModuleInfo) => getContent(moduleInfo, 'parameter');\n\n// Inject commonObj to return some functions\nexport const inject = (commonObj: Common) => {\n\tconst { getLigoDockerImage } = commonObj;\n\n\tconst getListDeclarationsCmd = async (\n\t\tparsedArgs: UnionOpts,\n\t\tsourceFile: string,\n\t): Promise<string> => {\n\t\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\t\tif (!projectDir) throw new Error(`No project directory provided`);\n\t\tconst baseCmd = `${commonObj.baseDriverCmd(projectDir)} info list-declarations`;\n\t\tconst inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);\n\t\tconst flags = '--display-format json';\n\t\tconst cmd = `${baseCmd} ${inputFile} ${flags}`;\n\t\treturn cmd;\n\t};\n\n\tconst listContractModules = async (\n\t\tparsedArgs: UnionOpts,\n\t\tsourceFile: string,\n\t): Promise<ModuleInfo[]> => {\n\t\ttry {\n\t\t\tawait getArch();\n\t\t\tconst cmd = await getListDeclarationsCmd(parsedArgs, sourceFile);\n\t\t\tconst { stderr, stdout } = await execCmd(cmd);\n\t\t\tif (stderr.length > 0) return Promise.reject(stderr);\n\n\t\t\treturn JSON.parse(stdout).declarations.reduce(\n\t\t\t\t(acc: ModuleInfo[], decl: string) => {\n\t\t\t\t\t// We need to process delcarations (decl) like so:\n\t\t\t\t\t// 1. If the decl is equal to the string \"main\", then the module type is \"file-main\" and the name of the module is the sourceFile.\n\t\t\t\t\t// 2. If the decl is equal to $main, then the module type is \"file-entry\" and the name fo the module is the sourceFile.\n\t\t\t\t\t// 3. If the decl ends with .main, then the module type is \"module-main\" and the name of the module is the decl without the .main suffix.\n\t\t\t\t\t// 4. If the decl ends with .$main, then the module type is \"module-entry\" and the name of the module is the decl without the .$main suffix.\n\t\t\t\t\t// Otherwise, this is not a declaration we care about.\n\t\t\t\t\tconst srcFile = removeExt(basename(sourceFile));\n\t\t\t\t\tconst syntax = extractExt(sourceFile).replace('.', '');\n\n\t\t\t\t\tif (decl === 'main') {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t...acc,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmoduleName: srcFile,\n\t\t\t\t\t\t\t\tsourceName: sourceFile,\n\t\t\t\t\t\t\t\tsourceFile,\n\t\t\t\t\t\t\t\ttype: 'file-main',\n\t\t\t\t\t\t\t\tsyntax,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t];\n\t\t\t\t\t} else if (decl === '$main') {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t...acc,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmoduleName: srcFile,\n\t\t\t\t\t\t\t\tsourceName: sourceFile,\n\t\t\t\t\t\t\t\tsourceFile,\n\t\t\t\t\t\t\t\ttype: 'file-entry',\n\t\t\t\t\t\t\t\tsyntax,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t];\n\t\t\t\t\t} else if (decl.endsWith('.main')) {\n\t\t\t\t\t\tconst moduleName = decl.replace(/\\.main$/, '');\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t...acc,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmoduleName,\n\t\t\t\t\t\t\t\tsourceName: `${sourceFile}/${moduleName}`,\n\t\t\t\t\t\t\t\tsourceFile,\n\t\t\t\t\t\t\t\ttype: 'module-main',\n\t\t\t\t\t\t\t\tsyntax,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t];\n\t\t\t\t\t} else if (decl.endsWith('.$main')) {\n\t\t\t\t\t\tconst moduleName = decl.replace(/\\.\\$main$/, '');\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t...acc,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmoduleName,\n\t\t\t\t\t\t\t\tsourceName: `${sourceFile}/${moduleName}`,\n\t\t\t\t\t\t\t\tsourceFile,\n\t\t\t\t\t\t\t\ttype: 'module-entry',\n\t\t\t\t\t\t\t\tsyntax,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t[],\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tconst formattedErr = err instanceof Error ? formatLigoError(err) : err;\n\t\t\temitExternalError(err, sourceFile);\n\t\t\treturn [];\n\t\t}\n\t};\n\n\tconst getCompileContractCmd = async (\n\t\tparsedArgs: Opts,\n\t\tsourceFile: string,\n\t\tmodule: ModuleInfo,\n\t): Promise<string> => {\n\t\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\t\tif (!projectDir) throw new Error(`No project directory provided`);\n\t\tconst baseCmd = `${commonObj.baseDriverCmd(projectDir)} compile contract`;\n\t\tconst inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);\n\t\tconst outputFile = `-o ${getOutputContractFilename(parsedArgs, module)}`;\n\t\tconst flags = isOutputFormatJSON(parsedArgs)\n\t\t\t? ' --michelson-format json '\n\t\t\t: '';\n\t\tconst moduleFlag = module.type.startsWith('file-')\n\t\t\t? ''\n\t\t\t: `-m ${module.moduleName}`;\n\t\tconst cmd = `${baseCmd} ${inputFile} ${outputFile} ${flags}${moduleFlag}`;\n\t\treturn cmd;\n\t};\n\n\tconst compileContract = async (\n\t\tparsedArgs: Opts,\n\t\tsourceFile: string,\n\t\tmodule: ModuleInfo,\n\t): Promise<TableRow> => {\n\t\ttry {\n\t\t\tawait getArch();\n\t\t\tconst cmd = await getCompileContractCmd(parsedArgs, sourceFile, module);\n\t\t\tconst { stderr } = await execCmd(cmd);\n\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\n\t\t\treturn {\n\t\t\t\tsource: module.sourceName,\n\t\t\t\tartifact: getOutputContractFilename(parsedArgs, module),\n\t\t\t};\n\t\t} catch (err) {\n\t\t\temitExternalError(err, sourceFile);\n\t\t\treturn {\n\t\t\t\tsource: module.sourceName,\n\t\t\t\tartifact: COMPILE_ERR_MSG,\n\t\t\t};\n\t\t}\n\t};\n\n\tconst getCompileExprCmd = (\n\t\tparsedArgs: Opts,\n\t\tsourceFile: string,\n\t\tmodule: ModuleInfo,\n\t\texprKind: ExprKind,\n\t\texprName: string,\n\t): string => {\n\t\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\t\tif (!projectDir) throw new Error(`No project directory provided`);\n\t\tconst compilerType = isStorageKind(exprKind) ? 'storage' : 'parameter';\n\t\tconst baseCmd = `${commonObj.baseDriverCmd(projectDir)} compile ${compilerType}`;\n\t\tconst inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);\n\t\tconst outputFile = `-o ${\n\t\t\tgetOutputExprFilename(\n\t\t\t\tparsedArgs,\n\t\t\t\tmodule,\n\t\t\t\texprKind,\n\t\t\t\texprName,\n\t\t\t)\n\t\t}`;\n\t\tconst flags = isOutputFormatJSON(parsedArgs)\n\t\t\t? ' --michelson-format json '\n\t\t\t: '';\n\n\t\t// Parameter and Storage list files are expected to import the smart contract file as the \"Contract\" module.\n\t\tconst moduleFlag = (() => {\n\t\t\tswitch (module.type) {\n\t\t\t\tcase 'file-main':\n\t\t\t\tcase 'file-entry':\n\t\t\t\t\treturn '-m Contract';\n\t\t\t\tdefault:\n\t\t\t\t\treturn `-m Contract.${module.moduleName}`;\n\t\t\t}\n\t\t})();\n\n\t\tconst cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile} ${flags} ${moduleFlag}`;\n\t\treturn cmd;\n\t};\n\n\tconst compileExpr = (\n\t\tparsedArgs: Opts,\n\t\tsourceFile: string,\n\t\tmodule: ModuleInfo,\n\t\texprKind: ExprKind,\n\t) =>\n\t(exprName: string): Promise<TableRow> => {\n\t\treturn getArch()\n\t\t\t.then(() => getCompileExprCmd(parsedArgs, sourceFile, module, exprKind, exprName))\n\t\t\t.then(execCmd)\n\t\t\t.then(({ stderr }) => {\n\t\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\t\t\tconst artifactName = getOutputExprFilename(\n\t\t\t\t\tparsedArgs,\n\t\t\t\t\tmodule,\n\t\t\t\t\texprKind,\n\t\t\t\t\texprName,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tsource: module.sourceName,\n\t\t\t\t\tartifact: artifactName,\n\t\t\t\t};\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\treturn {\n\t\t\t\t\tsource: module.sourceName,\n\t\t\t\t\tartifact: `${exprName} in ${sourceFile} not compiled`,\n\t\t\t\t\terr,\n\t\t\t\t};\n\t\t\t});\n\t};\n\n\tconst compileExprs = async (\n\t\tparsedArgs: Opts,\n\t\tsourceFile: string,\n\t\tmodule: ModuleInfo,\n\t\texprKind: ExprKind,\n\t): Promise<TableRow[]> => {\n\t\t// Get expressions from file\n\t\tlet exprs = [];\n\t\ttry {\n\t\t\texprs = await getExprNames(parsedArgs, sourceFile);\n\t\t} catch (err) {\n\t\t\temitExternalError(err, sourceFile);\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tsource: module.sourceName,\n\t\t\t\t\tartifact: `No ${isStorageKind(exprKind) ? 'storage' : 'parameter'} expressions compiled`,\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\n\t\tconst results = await Promise.all(\n\t\t\texprs.map(async (exprName, index) => {\n\t\t\t\tconst compileResult = await compileExpr(\n\t\t\t\t\tparsedArgs,\n\t\t\t\t\tsourceFile,\n\t\t\t\t\tmodule,\n\t\t\t\t\texprKind === 'storage' && index === 0 ? 'default_storage' : exprKind,\n\t\t\t\t)(exprName);\n\t\t\t\treturn compileResult;\n\t\t\t}),\n\t\t);\n\n\t\t// Collect errors\n\t\tconst errors = results.reduce((acc, result) => {\n\t\t\tif (result.err) {\n\t\t\t\t// If its not an Error object, then just add it to the list\n\t\t\t\tif (!(result.err instanceof Error)) return [...acc, result.err];\n\n\t\t\t\t// Otherwise, get all ligo errors and ensure that the list is unique\n\t\t\t\tconst ligoErrs = (\n\t\t\t\t\tacc.filter(err => err instanceof Error) as Error[]\n\t\t\t\t).map(err => err.message);\n\n\t\t\t\tconst formattedError = formatLigoError(result.err);\n\n\t\t\t\treturn ligoErrs.includes(formattedError.message)\n\t\t\t\t\t? acc\n\t\t\t\t\t: [...acc, formattedError];\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, [] as unknown[]);\n\n\t\t// Collect table rows\n\t\tconst retval = results.map(({ source, artifact }) => ({\n\t\t\tsource,\n\t\t\tartifact,\n\t\t}));\n\n\t\tif (errors.length) emitExternalError(errors, sourceFile);\n\n\t\treturn retval;\n\t};\n\n\tconst compileContractWithStorageAndParameter = async (\n\t\tparsedArgs: Opts,\n\t\tsourceFile: string,\n\t\tmodule: ModuleInfo,\n\t): Promise<TableRow[]> => {\n\t\tconst contractCompileResult = await compileContract(\n\t\t\tparsedArgs,\n\t\t\tsourceFile,\n\t\t\tmodule,\n\t\t);\n\t\tif (contractCompileResult.artifact === COMPILE_ERR_MSG) return [contractCompileResult];\n\n\t\tconst storageListFile = `${module.moduleName}.storageList${\n\t\t\textractExt(\n\t\t\t\tsourceFile,\n\t\t\t)\n\t\t}`;\n\t\tconst storageListFilename = getInputFilenameAbsPath(\n\t\t\tparsedArgs,\n\t\t\tstorageListFile,\n\t\t);\n\t\tconst storageCompileResult = await access(storageListFilename)\n\t\t\t.then(() => compileExprs(parsedArgs, storageListFile, module, 'storage'))\n\t\t\t.catch(() => {\n\t\t\t\tsendWarn(\n\t\t\t\t\t`Note: storage file associated with \"${module.moduleName}\" can't be found, so \"${storageListFile}\" has been created for you. Use this file to define all initial storage values for this contract\\n`,\n\t\t\t\t);\n\t\t\t\treturn writeFile(\n\t\t\t\t\tstorageListFilename,\n\t\t\t\t\tinitContentForStorage(module),\n\t\t\t\t\t'utf8',\n\t\t\t\t);\n\t\t\t});\n\n\t\tconst parameterListFile = `${module.moduleName}.parameterList${\n\t\t\textractExt(\n\t\t\t\tsourceFile,\n\t\t\t)\n\t\t}`;\n\t\tconst parameterListFilename = getInputFilenameAbsPath(\n\t\t\tparsedArgs,\n\t\t\tparameterListFile,\n\t\t);\n\t\tconst parameterCompileResult = await access(parameterListFilename)\n\t\t\t.then(() => compileExprs(parsedArgs, parameterListFile, module, 'parameter'))\n\t\t\t.catch(() => {\n\t\t\t\tsendWarn(\n\t\t\t\t\t`Note: parameter file associated with \"${module.moduleName}\" can't be found, so \"${parameterListFile}\" has been created for you. Use this file to define all parameter values for this contract\\n`,\n\t\t\t\t);\n\t\t\t\treturn writeFile(\n\t\t\t\t\tparameterListFilename,\n\t\t\t\t\tinitContentForParameter(module),\n\t\t\t\t\t'utf8',\n\t\t\t\t);\n\t\t\t});\n\n\t\tconst storageArtifacts = storageCompileResult\n\t\t\t? storageCompileResult.map(res => res.artifact).join('\\n')\n\t\t\t: '';\n\t\tconst parameterArtifacts = parameterCompileResult\n\t\t\t? parameterCompileResult.map(res => res.artifact).join('\\n')\n\t\t\t: '';\n\n\t\tconst combinedArtifact = [\n\t\t\tcontractCompileResult.artifact,\n\t\t\tstorageArtifacts,\n\t\t\tparameterArtifacts,\n\t\t]\n\t\t\t.filter(Boolean)\n\t\t\t.join('\\n');\n\n\t\tconst combinedRow: TableRow = {\n\t\t\tsource: module.sourceName,\n\t\t\tartifact: combinedArtifact,\n\t\t};\n\n\t\treturn [combinedRow];\n\t};\n\n\treturn {\n\t\tgetLigoDockerImage,\n\t\tgetListDeclarationsCmd,\n\t\tlistContractModules,\n\t\tgetCompileContractCmd,\n\t\tcompileContract,\n\t\tgetCompileExprCmd,\n\t\tcompileExpr,\n\t\tcompileExprs,\n\t\tcompileContractWithStorageAndParameter,\n\t};\n};\n\nexport const compile = async (\n\tcommonObj: Common,\n\tparsedArgs: Opts,\n): Promise<void> => {\n\tconst { listContractModules, compileContractWithStorageAndParameter } = inject(commonObj);\n\n\tconst sourceFile = parsedArgs.sourceFile;\n\tif (!isLIGOFile(sourceFile)) {\n\t\tsendErr(`${sourceFile} is not a LIGO file`);\n\t\treturn;\n\t}\n\tif (isStorageListFile(sourceFile) || isParameterListFile(sourceFile)) {\n\t\tsendErr(\n\t\t\t`Storage and parameter list files are not meant to be compiled directly`,\n\t\t);\n\t\treturn;\n\t}\n\tif (isUnsupportedLigoSyntax(sourceFile)) {\n\t\tsendErr(\n\t\t\t`Unsupported LIGO syntax detected in ${sourceFile}. Note, we only support .jsligo and .mligo files.`,\n\t\t);\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst modules = await listContractModules(parsedArgs, sourceFile);\n\t\tif (modules.length === 0) {\n\t\t\treturn sendJsonRes([\n\t\t\t\t{\n\t\t\t\t\tsource: sourceFile,\n\t\t\t\t\tartifact:\n\t\t\t\t\t\t`No contract modules found in \"${sourceFile}\".\\nIf your contract is defined within a namespace, please ensure that it is exported from the contract file.\"`,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\n\t\tlet allCompileResults: TableRow[] = [];\n\t\tfor (const module of modules) {\n\t\t\t// If we're only to compile a particular module, then we'll skip any that don't match\n\t\t\tif (parsedArgs.module && parsedArgs.module !== module.moduleName) continue;\n\n\t\t\tconst compileResults = await compileContractWithStorageAndParameter(\n\t\t\t\tparsedArgs,\n\t\t\t\tsourceFile,\n\t\t\t\tmodule,\n\t\t\t);\n\t\t\tallCompileResults = allCompileResults.concat(compileResults);\n\t\t}\n\n\t\tsendJsonRes(allCompileResults, {\n\t\t\tfooter: `\\nCompiled ${allCompileResults.length} contract(s) in \"${sourceFile}\"`,\n\t\t});\n\t} catch (err) {\n\t\tsendErr(`Error processing \"${sourceFile}\": ${err}`);\n\t}\n};\n\nexport default compile;\n","import { sendErr, sendJsonRes } from '@taqueria/node-sdk';\nimport glob from 'fast-glob';\nimport { join } from 'path';\nimport { Common, CompileAllOpts, CompileAllOpts as Opts, CompileOpts } from './common';\nimport { inject, isParameterListFile, isStorageListFile, TableRow } from './compile';\n\nconst compileAll = async (commonObj: Common, parsedArgs: Opts): Promise<void> => {\n\tconst { listContractModules, compileContractWithStorageAndParameter } = inject(commonObj);\n\n\tlet compilePromises: Promise<TableRow[]>[] = [];\n\n\tconst contractFilenames = await glob(\n\t\t['**/*.ligo', '**/*.religo', '**/*.mligo', '**/*.jsligo'],\n\t\t{\n\t\t\tcwd: join(parsedArgs.config.projectDir, parsedArgs.config.contractsDir ?? 'contracts'),\n\t\t\tabsolute: false,\n\t\t},\n\t);\n\n\tfor (const filename of contractFilenames) {\n\t\tif (isStorageListFile(filename) || isParameterListFile(filename)) continue;\n\t\tconst moduleNames = await listContractModules(parsedArgs as unknown as CompileAllOpts, filename);\n\t\tfor (const moduleName of moduleNames) {\n\t\t\tcompilePromises.push(compileContractWithStorageAndParameter(parsedArgs as CompileOpts, filename, moduleName));\n\t\t}\n\t}\n\n\treturn Promise.all(compilePromises)\n\t\t.then(tables => tables.flat())\n\t\t.then(sendJsonRes)\n\t\t.catch(err => sendErr(err, false));\n};\n\nexport default compileAll;\n","import { sendAsyncErr, sendRes, spawnCmd } from '@taqueria/node-sdk';\nimport { Common, LigoOpts as Opts } from './common';\n\nconst getArbitraryLigoCmd = (\n\tcommonObj: Common,\n\tparsedArgs: Opts,\n\tuserArgs: string,\n): [string, Record<string, string>] => {\n\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\tif (!projectDir) throw `No project directory provided`;\n\n\tconst processedUserArgs = userArgs\n\t\t.split(' ')\n\t\t.map(arg => (arg.startsWith('\\\\-') ? arg.substring(1) : arg))\n\t\t.filter(arg => arg);\n\n\tconst cmd = `${commonObj.baseDriverCmd(projectDir)} ${processedUserArgs.join(' ')}`;\n\n\tconst envVars = { DOCKER_DEFAULT_PLATFORM: 'linux/amd64' };\n\treturn [cmd, envVars];\n};\n\nconst runArbitraryLigoCmd = (\n\tcommonObj: Common,\n\tparsedArgs: Opts,\n\tuserCmd: string,\n): Promise<string> => {\n\tlet [cmd, envVars] = getArbitraryLigoCmd(commonObj, parsedArgs, userCmd);\n\treturn spawnCmd(cmd, envVars)\n\t\t.then(code =>\n\t\t\tcode !== null && code === 0\n\t\t\t\t? `Command \"${cmd}\" ran successfully by LIGO`\n\t\t\t\t: `Command \"${cmd}\" failed. Please check your command`\n\t\t)\n\t\t.catch(err => sendAsyncErr(`An internal error has occurred: ${err.message}`));\n};\n\nconst ligo = (commonObj: Common, parsedArgs: Opts): Promise<void> => {\n\tconst args = parsedArgs.command;\n\treturn runArbitraryLigoCmd(commonObj, parsedArgs, args)\n\t\t.then(sendRes)\n\t\t.catch(err => sendAsyncErr(err, false));\n};\n\nexport default ligo;\n","import { execCmd, getArch, sendAsyncErr, sendJsonRes, sendWarn } from '@taqueria/node-sdk';\nimport { Common, emitExternalError, getInputFilenameRelPath, TestOpts as Opts } from './common';\n\ntype TableRow = { contract: string; testResults: string };\n\nconst inject = (commonObj: Common) => {\n\tconst { baseDriverCmd } = commonObj;\n\n\tconst getTestContractCmd = (parsedArgs: Opts, sourceFile: string): string => {\n\t\tconst projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;\n\t\tif (!projectDir) throw `No project directory provided`;\n\t\tconst baseCmd = `${baseDriverCmd(projectDir)} run test`;\n\t\tconst inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);\n\t\tconst cmd = `${baseCmd} ${inputFile}`;\n\t\treturn cmd;\n\t};\n\n\tconst testContract = (\n\t\tparsedArgs: Opts,\n\t\tsourceFile: string,\n\t): Promise<TableRow> =>\n\t\tgetArch()\n\t\t\t.then(() => getTestContractCmd(parsedArgs, sourceFile))\n\t\t\t.then(execCmd)\n\t\t\t.then(({ stdout, stderr }) => {\n\t\t\t\tif (stderr.length > 0) sendWarn(stderr);\n\t\t\t\tconst result = '🎉 All tests passed 🎉';\n\t\t\t\treturn {\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\ttestResults: stdout.length > 0 ? `${stdout}\\n${result}` : result,\n\t\t\t\t};\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\temitExternalError(err, sourceFile);\n\t\t\t\treturn {\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\ttestResults: 'Some tests failed :(',\n\t\t\t\t};\n\t\t\t});\n\n\treturn {\n\t\ttestContract,\n\t\tgetTestContractCmd,\n\t};\n};\n\nconst test = (commonObj: Common, parsedArgs: Opts): Promise<void> => {\n\tconst { testContract } = inject(commonObj);\n\n\tconst sourceFile = parsedArgs.sourceFile;\n\tif (!sourceFile) return sendAsyncErr(`No source file provided`);\n\treturn testContract(parsedArgs, sourceFile)\n\t\t.then(result => [result])\n\t\t.then(sendJsonRes)\n\t\t.catch(err => sendAsyncErr(err, false));\n};\n\nexport default test;\n"],"mappings":"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","names":["import_node_sdk","import_node_sdk","import_node_sdk","import_node_sdk","import_promises","import_path","module","import_node_sdk","import_path","glob","import_node_sdk","import_node_sdk","inject","baseDriverCmd"]}