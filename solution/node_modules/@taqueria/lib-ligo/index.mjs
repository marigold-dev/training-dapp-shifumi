var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// index.ts
import { Option, Plugin, PositionalArg, Task, Template } from "@taqueria/node-sdk";

// createContract.ts
import { sendAsyncErr } from "@taqueria/node-sdk";
import { writeFile } from "fs/promises";

// ligo_templates.ts
var ligo_templates_exports = {};
__export(ligo_templates_exports, {
  jsligo_template: () => jsligo_template,
  mligo_template: () => mligo_template
});
var mligo_template = `
type storage = int
type return = operation list * storage

(* Three entrypoints *)
[@entry] let increment (delta : int) (store : storage) : return =
  [], store + delta
[@entry] let decrement (delta : int) (store : storage) : return =
  [], store - delta
[@entry] let reset (() : unit) (_ : storage) : return =
  [], 0
`;
var jsligo_template = `
type storage = int;
type ret = [list<operation>, storage];

// Three entrypoints

// @entry
const increment = (delta : int, store : storage) : ret =>
  [list([]), store + delta];

// @entry
const decrement = (delta : int, store : storage) : ret =>
  [list([]), store - delta];

// @entry
const reset = (_ : unit, _ : storage) : ret =>
  [list([]), 0];
`;

// createContract.ts
var getLigoTemplate = async (contractName, syntax, templateOverrides) => {
  const matchResult = contractName.match(/\.[^.]+$/);
  const ext = matchResult ? matchResult[0].substring(1) : null;
  const templates = templateOverrides ?? ligo_templates_exports;
  if (syntax === "mligo")
    return templates.mligo_template;
  if (syntax === "jsligo")
    return templates.jsligo_template;
  if (syntax === void 0) {
    if (ext === "mligo")
      return templates.mligo_template;
    if (ext === "jsligo")
      return templates.jsligo_template;
    return sendAsyncErr(
      `Unable to infer LIGO syntax from "${contractName}". Please specify a LIGO syntax via the --syntax option`
    );
  } else {
    return sendAsyncErr(`"${syntax}" is not a valid syntax. Please specify a valid LIGO syntax`);
  }
};
var createContract = (templates) => (args) => {
  const unsafeOpts = args;
  const contractName = unsafeOpts.sourceFileName;
  const syntax = unsafeOpts.syntax;
  const contractsDir = `${args.config.projectDir}/${args.config.contractsDir}`;
  return getLigoTemplate(contractName, syntax, templates).then((ligo_template) => writeFile(`${contractsDir}/${contractName}`, ligo_template));
};
var createContract_default = createContract;

// main.ts
import { sendAsyncErr as sendAsyncErr5, sendAsyncRes } from "@taqueria/node-sdk";

// common.ts
import { getDockerImage, sendErr } from "@taqueria/node-sdk";
import * as fs from "fs";
import { delimiter, join } from "path";
var getInputFilenameAbsPath = (parsedArgs, sourceFile) => join(
  parsedArgs.config.projectDir,
  parsedArgs.config.contractsDir ?? "contracts",
  sourceFile
);
var getInputFilenameRelPath = (parsedArgs, sourceFile) => join(parsedArgs.config.contractsDir ?? "contracts", sourceFile);
var formatLigoError = (err) => {
  let result = err.message.replace(/Command failed.+?\n/, "");
  if (result.includes(
    "An internal error ocurred. Please, contact the developers."
  ) && result.includes("Module Contract not found with last Contract.")) {
    result = `By convention, Taqueria expects you to import your contract with Contract as the module name.
For instance, if you have a contract in a file called "increment.mligo", in your parameter/storage list file you must include #import "Increment.mligo" "Contract" for compilation to be successful.`;
  } else {
    const regex = /contracts\/(.+): No such file or directory/;
    const match = regex.exec(result);
    if (match) {
      const filename = match[1];
      result = `The file ${filename} was not found. Please ensure that the file exists and that it is in the contracts directory.`;
    }
  }
  err.message = result.replace(
    "An internal error ocurred. Please, contact the developers.",
    "The LIGO compiler experienced an internal error. Please contact the LIGO developers."
  ).replace(
    /Module ("Contract\.[^"]+") not found/,
    "The module $1 was not found. If your contract is defined within a namespace, please ensure that it has been exported."
  );
  return err;
};
var emitExternalError = (errs, sourceFile) => {
  sendErr(`
=== Error messages for ${sourceFile} ===`);
  const errors = Array.isArray(errs) ? errs : [errs];
  errors.map((err) => {
    err instanceof Error ? sendErr(err.message) : sendErr(err);
  });
  sendErr(`===`);
};
var configure = (dockerImage, dockerImageEnvVar, canUseLIGOBinary) => ({
  LIGO_DEFAULT_IMAGE: dockerImage,
  LIGO_IMAGE_ENV_VAR: dockerImageEnvVar,
  getLigoDockerImage: () => getDockerImage(dockerImage, dockerImageEnvVar),
  baseDriverCmd: (projectDir) => baseDriverCmd(projectDir, dockerImage, canUseLIGOBinary)
});
function exists(path) {
  try {
    fs.accessSync(path, fs.constants.X_OK);
    return true;
  } catch {
    return false;
  }
}
function getLigoBinaryFromPath() {
  const { PATH } = process.env;
  if (!PATH) {
    return null;
  }
  const paths = PATH.split(delimiter);
  for (const candidatePath of paths) {
    const possibleLigoPath = join(candidatePath, "ligo");
    if (exists(possibleLigoPath)) {
      return possibleLigoPath;
    }
  }
  return null;
}
function baseDriverCmd(projectDir, ligoDockerImage, canUseLIGOBinary) {
  const ligoBinaryFromPath = canUseLIGOBinary ? getLigoBinaryFromPath() : null;
  if (ligoBinaryFromPath !== null) {
    return ligoBinaryFromPath;
  } else {
    return `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v "${projectDir}":/project -w /project -u $(id -u):$(id -g) ${ligoDockerImage}`;
  }
}

// compile.ts
import {
  execCmd,
  getArch,
  getArtifactsDir,
  sendErr as sendErr2,
  sendJsonRes,
  sendWarn
} from "@taqueria/node-sdk";
import { createReadStream } from "fs";
import { access, writeFile as writeFile2 } from "fs/promises";
import { basename, join as join2 } from "path";
import * as readline from "readline";
var COMPILE_ERR_MSG = "Not compiled";
var isStorageKind = (exprKind) => exprKind === "storage" || exprKind === "default_storage";
var isSupportedLigoSyntax = (sourceFile) => /\.(mligo|jsligo)$/.test(sourceFile);
var isUnsupportedLigoSyntax = (sourceFile) => /\.(ligo|religo)$/.test(sourceFile);
var isLIGOFile = (sourceFile) => isSupportedLigoSyntax(sourceFile) || isUnsupportedLigoSyntax(sourceFile);
var isStorageListFile = (sourceFile) => /.+\.(storageList|storages)\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
var isParameterListFile = (sourceFile) => /.+\.(parameterList|parameters)\.(ligo|religo|mligo|jsligo)$/.test(
  sourceFile
);
var extractExt = (path) => {
  const matchResult = path.match(/\.(ligo|religo|mligo|jsligo)$/);
  return matchResult ? matchResult[0] : "";
};
var removeExt = (path) => {
  const extRegex = new RegExp(extractExt(path));
  return path.replace(extRegex, "");
};
var isOutputFormatJSON = (parsedArgs) => parsedArgs.json;
var getOutputContractFilename = (parsedArgs, module) => {
  const ext = isOutputFormatJSON(parsedArgs) ? ".json" : ".tz";
  return join2(getArtifactsDir(parsedArgs), `${module.moduleName}${ext}`);
};
var getOutputExprFilename = (parsedArgs, module, exprKind, exprName) => {
  const contractName = module.moduleName;
  const ext = isOutputFormatJSON(parsedArgs) ? ".json" : ".tz";
  const outputFile = exprKind === "default_storage" ? `${contractName}.default_storage${ext}` : `${contractName}.${exprKind}.${exprName}${ext}`;
  return join2(getArtifactsDir(parsedArgs), `${outputFile}`);
};
var getExprNames = (parsedArgs, sourceFile) => {
  return new Promise((resolve, reject) => {
    const inputFilePath = getInputFilenameAbsPath(parsedArgs, sourceFile);
    const readInterface = readline.createInterface({
      input: createReadStream(inputFilePath),
      output: process.stdout
    });
    const variableNames = [];
    readInterface.on("line", function(line) {
      if (!line.trim().startsWith("//")) {
        const matches = line.match(/(?<=\s*(let|const)\s+)[a-zA-Z0-9_]+/g);
        if (matches) {
          variableNames.push(...matches);
        }
      }
    });
    readInterface.on("close", function() {
      resolve(variableNames);
    });
  });
};
var getInitialMessage = (pair, module) => {
  const messages = {
    "mligo-file-main": `// When this file was created, the smart contract was defined with a main function that was not within a named module. As such, the examples below are written with that assumption in mind.`,
    "mligo-file-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was not within a named module. As such, the examples below are written with that assumption in mind.`,
    "mligo-module-main": `// When this file was created, the smart contract was defined with a main function that was within a named module. As such, the examples below are written with that assumption in mind.`,
    "mligo-module-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was within a named module. As such, the examples below are written with that assumption in mind.`,
    "jsligo-file-main": `// When this file was created, the smart contract was defined with a main function that was not within a namespace. As such, the examples below are written with that assumption in mind.
// NOTE: The "storage" type should be exported from the contract file (${module.sourceFile})`,
    "jsligo-file-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was not within a namespace. As such, the examples below are written with that assumption in mind.`,
    "jsligo-module-main": `// When this file was created, the smart contract was defined with a main function that was within a namespace. As such, the examples below are written with that assumption in mind.
// NOTE: The "storage" type should be exported from the contract file (${module.sourceFile})`,
    "jsligo-module-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was within a namespace. As such, the examples below are written with that assumption in mind.`
    // ... any other combinations
  };
  return messages[pair] || "// This file was created by Taqueria.";
};
var getCommonMsg = (langType, listType) => {
  const varKeyword = langType === "mligo" ? "let" : "const";
  const commonMsgForStorage = `// IMPORTANT: We suggest always explicitly typing your storage values:
// E.g.: \`${varKeyword} storage: int = 10\` or \`${varKeyword} storage: Contract.storage = 10\``;
  const commonMsgForParameter = `// IMPORTANT: We suggest always explicitly typing your parameter values:
// E.g.: \`${varKeyword} parameter: int = 10\` or \`${varKeyword} parameter: Contract.parameter = 10\``;
  return listType === "storage" ? commonMsgForStorage : commonMsgForParameter;
};
var getContent = (moduleInfo, listType) => {
  const linkToContract = `#import "${moduleInfo.sourceFile}" "Contract"`;
  const pair = `${moduleInfo.syntax}-${moduleInfo.type}`;
  const initialMsg = getInitialMessage(pair, moduleInfo);
  const commonMsg = getCommonMsg(moduleInfo.syntax, listType);
  return `${linkToContract}

${initialMsg}

${commonMsg}`;
};
var initContentForStorage = (moduleInfo) => getContent(moduleInfo, "storage");
var initContentForParameter = (moduleInfo) => getContent(moduleInfo, "parameter");
var inject = (commonObj) => {
  const { getLigoDockerImage } = commonObj;
  const getListDeclarationsCmd = async (parsedArgs, sourceFile) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw new Error(`No project directory provided`);
    const baseCmd = `${commonObj.baseDriverCmd(projectDir)} info list-declarations`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const flags = "--display-format json";
    const cmd = `${baseCmd} ${inputFile} ${flags}`;
    return cmd;
  };
  const listContractModules = async (parsedArgs, sourceFile) => {
    try {
      await getArch();
      const cmd = await getListDeclarationsCmd(parsedArgs, sourceFile);
      const { stderr, stdout } = await execCmd(cmd);
      if (stderr.length > 0)
        return Promise.reject(stderr);
      return JSON.parse(stdout).declarations.reduce(
        (acc, decl) => {
          const srcFile = removeExt(basename(sourceFile));
          const syntax = extractExt(sourceFile).replace(".", "");
          if (decl === "main") {
            return [
              ...acc,
              {
                moduleName: srcFile,
                sourceName: sourceFile,
                sourceFile,
                type: "file-main",
                syntax
              }
            ];
          } else if (decl === "$main") {
            return [
              ...acc,
              {
                moduleName: srcFile,
                sourceName: sourceFile,
                sourceFile,
                type: "file-entry",
                syntax
              }
            ];
          } else if (decl.endsWith(".main")) {
            const moduleName = decl.replace(/\.main$/, "");
            return [
              ...acc,
              {
                moduleName,
                sourceName: `${sourceFile}/${moduleName}`,
                sourceFile,
                type: "module-main",
                syntax
              }
            ];
          } else if (decl.endsWith(".$main")) {
            const moduleName = decl.replace(/\.\$main$/, "");
            return [
              ...acc,
              {
                moduleName,
                sourceName: `${sourceFile}/${moduleName}`,
                sourceFile,
                type: "module-entry",
                syntax
              }
            ];
          }
          return acc;
        },
        []
      );
    } catch (err) {
      const formattedErr = err instanceof Error ? formatLigoError(err) : err;
      emitExternalError(err, sourceFile);
      return [];
    }
  };
  const getCompileContractCmd = async (parsedArgs, sourceFile, module) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw new Error(`No project directory provided`);
    const baseCmd = `${commonObj.baseDriverCmd(projectDir)} compile contract`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const outputFile = `-o ${getOutputContractFilename(parsedArgs, module)}`;
    const flags = isOutputFormatJSON(parsedArgs) ? " --michelson-format json " : "";
    const moduleFlag = module.type.startsWith("file-") ? "" : `-m ${module.moduleName}`;
    const cmd = `${baseCmd} ${inputFile} ${outputFile} ${flags}${moduleFlag}`;
    return cmd;
  };
  const compileContract = async (parsedArgs, sourceFile, module) => {
    try {
      await getArch();
      const cmd = await getCompileContractCmd(parsedArgs, sourceFile, module);
      const { stderr } = await execCmd(cmd);
      if (stderr.length > 0)
        sendWarn(stderr);
      return {
        source: module.sourceName,
        artifact: getOutputContractFilename(parsedArgs, module)
      };
    } catch (err) {
      emitExternalError(err, sourceFile);
      return {
        source: module.sourceName,
        artifact: COMPILE_ERR_MSG
      };
    }
  };
  const getCompileExprCmd = (parsedArgs, sourceFile, module, exprKind, exprName) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw new Error(`No project directory provided`);
    const compilerType = isStorageKind(exprKind) ? "storage" : "parameter";
    const baseCmd = `${commonObj.baseDriverCmd(projectDir)} compile ${compilerType}`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const outputFile = `-o ${getOutputExprFilename(
      parsedArgs,
      module,
      exprKind,
      exprName
    )}`;
    const flags = isOutputFormatJSON(parsedArgs) ? " --michelson-format json " : "";
    const moduleFlag = (() => {
      switch (module.type) {
        case "file-main":
        case "file-entry":
          return "-m Contract";
        default:
          return `-m Contract.${module.moduleName}`;
      }
    })();
    const cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile} ${flags} ${moduleFlag}`;
    return cmd;
  };
  const compileExpr = (parsedArgs, sourceFile, module, exprKind) => (exprName) => {
    return getArch().then(() => getCompileExprCmd(parsedArgs, sourceFile, module, exprKind, exprName)).then(execCmd).then(({ stderr }) => {
      if (stderr.length > 0)
        sendWarn(stderr);
      const artifactName = getOutputExprFilename(
        parsedArgs,
        module,
        exprKind,
        exprName
      );
      return {
        source: module.sourceName,
        artifact: artifactName
      };
    }).catch((err) => {
      return {
        source: module.sourceName,
        artifact: `${exprName} in ${sourceFile} not compiled`,
        err
      };
    });
  };
  const compileExprs = async (parsedArgs, sourceFile, module, exprKind) => {
    let exprs = [];
    try {
      exprs = await getExprNames(parsedArgs, sourceFile);
    } catch (err) {
      emitExternalError(err, sourceFile);
      return [
        {
          source: module.sourceName,
          artifact: `No ${isStorageKind(exprKind) ? "storage" : "parameter"} expressions compiled`
        }
      ];
    }
    const results = await Promise.all(
      exprs.map(async (exprName, index) => {
        const compileResult = await compileExpr(
          parsedArgs,
          sourceFile,
          module,
          exprKind === "storage" && index === 0 ? "default_storage" : exprKind
        )(exprName);
        return compileResult;
      })
    );
    const errors = results.reduce((acc, result) => {
      if (result.err) {
        if (!(result.err instanceof Error))
          return [...acc, result.err];
        const ligoErrs = acc.filter((err) => err instanceof Error).map((err) => err.message);
        const formattedError = formatLigoError(result.err);
        return ligoErrs.includes(formattedError.message) ? acc : [...acc, formattedError];
      }
      return acc;
    }, []);
    const retval = results.map(({ source, artifact }) => ({
      source,
      artifact
    }));
    if (errors.length)
      emitExternalError(errors, sourceFile);
    return retval;
  };
  const compileContractWithStorageAndParameter = async (parsedArgs, sourceFile, module) => {
    const contractCompileResult = await compileContract(
      parsedArgs,
      sourceFile,
      module
    );
    if (contractCompileResult.artifact === COMPILE_ERR_MSG)
      return [contractCompileResult];
    const storageListFile = `${module.moduleName}.storageList${extractExt(
      sourceFile
    )}`;
    const storageListFilename = getInputFilenameAbsPath(
      parsedArgs,
      storageListFile
    );
    const storageCompileResult = await access(storageListFilename).then(() => compileExprs(parsedArgs, storageListFile, module, "storage")).catch(() => {
      sendWarn(
        `Note: storage file associated with "${module.moduleName}" can't be found, so "${storageListFile}" has been created for you. Use this file to define all initial storage values for this contract
`
      );
      return writeFile2(
        storageListFilename,
        initContentForStorage(module),
        "utf8"
      );
    });
    const parameterListFile = `${module.moduleName}.parameterList${extractExt(
      sourceFile
    )}`;
    const parameterListFilename = getInputFilenameAbsPath(
      parsedArgs,
      parameterListFile
    );
    const parameterCompileResult = await access(parameterListFilename).then(() => compileExprs(parsedArgs, parameterListFile, module, "parameter")).catch(() => {
      sendWarn(
        `Note: parameter file associated with "${module.moduleName}" can't be found, so "${parameterListFile}" has been created for you. Use this file to define all parameter values for this contract
`
      );
      return writeFile2(
        parameterListFilename,
        initContentForParameter(module),
        "utf8"
      );
    });
    const storageArtifacts = storageCompileResult ? storageCompileResult.map((res) => res.artifact).join("\n") : "";
    const parameterArtifacts = parameterCompileResult ? parameterCompileResult.map((res) => res.artifact).join("\n") : "";
    const combinedArtifact = [
      contractCompileResult.artifact,
      storageArtifacts,
      parameterArtifacts
    ].filter(Boolean).join("\n");
    const combinedRow = {
      source: module.sourceName,
      artifact: combinedArtifact
    };
    return [combinedRow];
  };
  return {
    getLigoDockerImage,
    getListDeclarationsCmd,
    listContractModules,
    getCompileContractCmd,
    compileContract,
    getCompileExprCmd,
    compileExpr,
    compileExprs,
    compileContractWithStorageAndParameter
  };
};
var compile = async (commonObj, parsedArgs) => {
  const { listContractModules, compileContractWithStorageAndParameter } = inject(commonObj);
  const sourceFile = parsedArgs.sourceFile;
  if (!isLIGOFile(sourceFile)) {
    sendErr2(`${sourceFile} is not a LIGO file`);
    return;
  }
  if (isStorageListFile(sourceFile) || isParameterListFile(sourceFile)) {
    sendErr2(
      `Storage and parameter list files are not meant to be compiled directly`
    );
    return;
  }
  if (isUnsupportedLigoSyntax(sourceFile)) {
    sendErr2(
      `Unsupported LIGO syntax detected in ${sourceFile}. Note, we only support .jsligo and .mligo files.`
    );
    return;
  }
  try {
    const modules = await listContractModules(parsedArgs, sourceFile);
    if (modules.length === 0) {
      return sendJsonRes([
        {
          source: sourceFile,
          artifact: `No contract modules found in "${sourceFile}".
If your contract is defined within a namespace, please ensure that it is exported from the contract file."`
        }
      ]);
    }
    let allCompileResults = [];
    for (const module of modules) {
      if (parsedArgs.module && parsedArgs.module !== module.moduleName)
        continue;
      const compileResults = await compileContractWithStorageAndParameter(
        parsedArgs,
        sourceFile,
        module
      );
      allCompileResults = allCompileResults.concat(compileResults);
    }
    sendJsonRes(allCompileResults, {
      footer: `
Compiled ${allCompileResults.length} contract(s) in "${sourceFile}"`
    });
  } catch (err) {
    sendErr2(`Error processing "${sourceFile}": ${err}`);
  }
};
var compile_default = compile;

// compile-all.ts
import { sendErr as sendErr3, sendJsonRes as sendJsonRes2 } from "@taqueria/node-sdk";
import glob from "fast-glob";
import { join as join3 } from "path";
var compileAll = async (commonObj, parsedArgs) => {
  const { listContractModules, compileContractWithStorageAndParameter } = inject(commonObj);
  let compilePromises = [];
  const contractFilenames = await glob(
    ["**/*.ligo", "**/*.religo", "**/*.mligo", "**/*.jsligo"],
    {
      cwd: join3(parsedArgs.config.projectDir, parsedArgs.config.contractsDir ?? "contracts"),
      absolute: false
    }
  );
  for (const filename of contractFilenames) {
    if (isStorageListFile(filename) || isParameterListFile(filename))
      continue;
    const moduleNames = await listContractModules(parsedArgs, filename);
    for (const moduleName of moduleNames) {
      compilePromises.push(compileContractWithStorageAndParameter(parsedArgs, filename, moduleName));
    }
  }
  return Promise.all(compilePromises).then((tables) => tables.flat()).then(sendJsonRes2).catch((err) => sendErr3(err, false));
};
var compile_all_default = compileAll;

// ligo.ts
import { sendAsyncErr as sendAsyncErr3, sendRes as sendRes2, spawnCmd } from "@taqueria/node-sdk";
var getArbitraryLigoCmd = (commonObj, parsedArgs, userArgs) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const processedUserArgs = userArgs.split(" ").map((arg) => arg.startsWith("\\-") ? arg.substring(1) : arg).filter((arg) => arg);
  const cmd = `${commonObj.baseDriverCmd(projectDir)} ${processedUserArgs.join(" ")}`;
  const envVars = { DOCKER_DEFAULT_PLATFORM: "linux/amd64" };
  return [cmd, envVars];
};
var runArbitraryLigoCmd = (commonObj, parsedArgs, userCmd) => {
  let [cmd, envVars] = getArbitraryLigoCmd(commonObj, parsedArgs, userCmd);
  return spawnCmd(cmd, envVars).then(
    (code) => code !== null && code === 0 ? `Command "${cmd}" ran successfully by LIGO` : `Command "${cmd}" failed. Please check your command`
  ).catch((err) => sendAsyncErr3(`An internal error has occurred: ${err.message}`));
};
var ligo = (commonObj, parsedArgs) => {
  const args = parsedArgs.command;
  return runArbitraryLigoCmd(commonObj, parsedArgs, args).then(sendRes2).catch((err) => sendAsyncErr3(err, false));
};
var ligo_default = ligo;

// test.ts
import { execCmd as execCmd2, getArch as getArch2, sendAsyncErr as sendAsyncErr4, sendJsonRes as sendJsonRes3, sendWarn as sendWarn2 } from "@taqueria/node-sdk";
var inject2 = (commonObj) => {
  const { baseDriverCmd: baseDriverCmd2 } = commonObj;
  const getTestContractCmd = (parsedArgs, sourceFile) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw `No project directory provided`;
    const baseCmd = `${baseDriverCmd2(projectDir)} run test`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const cmd = `${baseCmd} ${inputFile}`;
    return cmd;
  };
  const testContract = (parsedArgs, sourceFile) => getArch2().then(() => getTestContractCmd(parsedArgs, sourceFile)).then(execCmd2).then(({ stdout, stderr }) => {
    if (stderr.length > 0)
      sendWarn2(stderr);
    const result = "\u{1F389} All tests passed \u{1F389}";
    return {
      contract: sourceFile,
      testResults: stdout.length > 0 ? `${stdout}
${result}` : result
    };
  }).catch((err) => {
    emitExternalError(err, sourceFile);
    return {
      contract: sourceFile,
      testResults: "Some tests failed :("
    };
  });
  return {
    testContract,
    getTestContractCmd
  };
};
var test = (commonObj, parsedArgs) => {
  const { testContract } = inject2(commonObj);
  const sourceFile = parsedArgs.sourceFile;
  if (!sourceFile)
    return sendAsyncErr4(`No source file provided`);
  return testContract(parsedArgs, sourceFile).then((result) => [result]).then(sendJsonRes3).catch((err) => sendAsyncErr4(err, false));
};
var test_default = test;

// main.ts
var main = (dockerImage, dockerImageEnvVar, canUseLIGOBinary) => (parsedArgs) => {
  const commonObj = configure(dockerImage, dockerImageEnvVar, canUseLIGOBinary);
  const unsafeOpts = parsedArgs;
  switch (unsafeOpts.task) {
    case "ligo":
      return ligo_default(commonObj, unsafeOpts);
    case "compile":
      return compile_default(commonObj, unsafeOpts);
    case "compile-all":
      return compile_all_default(commonObj, unsafeOpts);
    case "test":
      return test_default(commonObj, parsedArgs);
    case "get-image":
      return sendAsyncRes(commonObj.getLigoDockerImage());
    default:
      return sendAsyncErr5(`${unsafeOpts.task} is not an understood task by the LIGO plugin`);
  }
};
var main_default = main;

// index.ts
var configurePlugin = (settings) => {
  const schema = {
    name: settings.name,
    schema: "1.0",
    version: "0.1",
    alias: settings.alias,
    tasks: [
      Task.create({
        task: "ligo",
        command: "ligo",
        description: "This task allows you to run arbitrary LIGO native commands. Note that they might not benefit from the abstractions provided by Taqueria",
        options: [
          Option.create({
            shortFlag: "c",
            flag: "command",
            type: "string",
            description: "The command to be passed to the underlying LIGO binary, wrapped in quotes",
            required: true
          })
        ],
        handler: "proxy",
        encoding: "none"
      }),
      Task.create({
        task: "compile",
        command: "compile <sourceFile>",
        aliases: ["c", "compile-ligo"],
        description: "Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storage/parameter list files if they are found",
        options: [
          Option.create({
            flag: "json",
            boolean: true,
            description: "Emit JSON-encoded Michelson"
          }),
          Option.create({
            flag: "module",
            shortFlag: "m",
            type: "string",
            description: "The LIGO module to be compiled"
          })
        ],
        handler: "proxy",
        encoding: "json"
      }),
      Task.create({
        task: "compile-all",
        command: "compile-all",
        description: "Compile all main smart contracts written in a LIGO syntax to Michelson code, along with their associated storage/parameter list files if they are found",
        options: [
          Option.create({
            flag: "json",
            boolean: true,
            description: "Emit JSON-encoded Michelson"
          })
        ],
        handler: "proxy",
        encoding: "json"
      }),
      Task.create({
        task: "test",
        command: "test <sourceFile>",
        description: "Test a smart contract written in LIGO",
        handler: "proxy",
        encoding: "json"
      }),
      Task.create({
        task: "get-image",
        command: "get-image",
        description: "Gets the name of the image to be used",
        handler: "proxy",
        hidden: true
      })
    ],
    templates: [
      Template.create({
        template: "contract",
        command: "contract <sourceFileName>",
        description: "Create a LIGO contract with boilerplate code",
        positionals: [
          PositionalArg.create({
            placeholder: "sourceFileName",
            type: "string",
            description: "The name of the LIGO contract to generate"
          })
        ],
        options: [
          Option.create({
            shortFlag: "s",
            flag: "syntax",
            type: "string",
            description: "The syntax used in the contract"
          })
        ],
        handler: createContract_default(settings.templates)
      })
    ],
    proxy: main_default(settings.dockerImage, settings.dockerImageEnvVar, settings.canUseLIGOBinary),
    postInstall: `node ${__dirname}/postinstall.js`
  };
  return Plugin.create(() => settings.configurator ? settings.configurator(schema) : schema, settings.unparsedArgs);
};
export {
  configurePlugin
};
//# sourceMappingURL=index.mjs.map