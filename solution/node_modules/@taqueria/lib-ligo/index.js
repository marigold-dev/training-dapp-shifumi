"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var taqueria_lib_ligo_exports = {};
__export(taqueria_lib_ligo_exports, {
  configurePlugin: () => configurePlugin
});
module.exports = __toCommonJS(taqueria_lib_ligo_exports);
var import_node_sdk8 = require("@taqueria/node-sdk");

// createContract.ts
var import_node_sdk = require("@taqueria/node-sdk");
var import_promises = require("fs/promises");

// ligo_templates.ts
var ligo_templates_exports = {};
__export(ligo_templates_exports, {
  jsligo_template: () => jsligo_template,
  mligo_template: () => mligo_template
});
var mligo_template = `
type storage = int
type return = operation list * storage

(* Three entrypoints *)
[@entry] let increment (delta : int) (store : storage) : return =
  [], store + delta
[@entry] let decrement (delta : int) (store : storage) : return =
  [], store - delta
[@entry] let reset (() : unit) (_ : storage) : return =
  [], 0
`;
var jsligo_template = `
type storage = int;
type ret = [list<operation>, storage];

// Three entrypoints

// @entry
const increment = (delta : int, store : storage) : ret =>
  [list([]), store + delta];

// @entry
const decrement = (delta : int, store : storage) : ret =>
  [list([]), store - delta];

// @entry
const reset = (_ : unit, _ : storage) : ret =>
  [list([]), 0];
`;

// createContract.ts
var getLigoTemplate = async (contractName, syntax, templateOverrides) => {
  const matchResult = contractName.match(/\.[^.]+$/);
  const ext = matchResult ? matchResult[0].substring(1) : null;
  const templates = templateOverrides ?? ligo_templates_exports;
  if (syntax === "mligo")
    return templates.mligo_template;
  if (syntax === "jsligo")
    return templates.jsligo_template;
  if (syntax === void 0) {
    if (ext === "mligo")
      return templates.mligo_template;
    if (ext === "jsligo")
      return templates.jsligo_template;
    return (0, import_node_sdk.sendAsyncErr)(
      `Unable to infer LIGO syntax from "${contractName}". Please specify a LIGO syntax via the --syntax option`
    );
  } else {
    return (0, import_node_sdk.sendAsyncErr)(`"${syntax}" is not a valid syntax. Please specify a valid LIGO syntax`);
  }
};
var createContract = (templates) => (args) => {
  const unsafeOpts = args;
  const contractName = unsafeOpts.sourceFileName;
  const syntax = unsafeOpts.syntax;
  const contractsDir = `${args.config.projectDir}/${args.config.contractsDir}`;
  return getLigoTemplate(contractName, syntax, templates).then((ligo_template) => (0, import_promises.writeFile)(`${contractsDir}/${contractName}`, ligo_template));
};
var createContract_default = createContract;

// main.ts
var import_node_sdk7 = require("@taqueria/node-sdk");

// common.ts
var import_node_sdk2 = require("@taqueria/node-sdk");
var fs = __toESM(require("fs"));
var import_path = require("path");
var getInputFilenameAbsPath = (parsedArgs, sourceFile) => (0, import_path.join)(
  parsedArgs.config.projectDir,
  parsedArgs.config.contractsDir ?? "contracts",
  sourceFile
);
var getInputFilenameRelPath = (parsedArgs, sourceFile) => (0, import_path.join)(parsedArgs.config.contractsDir ?? "contracts", sourceFile);
var formatLigoError = (err) => {
  let result = err.message.replace(/Command failed.+?\n/, "");
  if (result.includes(
    "An internal error ocurred. Please, contact the developers."
  ) && result.includes("Module Contract not found with last Contract.")) {
    result = `By convention, Taqueria expects you to import your contract with Contract as the module name.
For instance, if you have a contract in a file called "increment.mligo", in your parameter/storage list file you must include #import "Increment.mligo" "Contract" for compilation to be successful.`;
  } else {
    const regex = /contracts\/(.+): No such file or directory/;
    const match = regex.exec(result);
    if (match) {
      const filename = match[1];
      result = `The file ${filename} was not found. Please ensure that the file exists and that it is in the contracts directory.`;
    }
  }
  err.message = result.replace(
    "An internal error ocurred. Please, contact the developers.",
    "The LIGO compiler experienced an internal error. Please contact the LIGO developers."
  ).replace(
    /Module ("Contract\.[^"]+") not found/,
    "The module $1 was not found. If your contract is defined within a namespace, please ensure that it has been exported."
  );
  return err;
};
var emitExternalError = (errs, sourceFile) => {
  (0, import_node_sdk2.sendErr)(`
=== Error messages for ${sourceFile} ===`);
  const errors = Array.isArray(errs) ? errs : [errs];
  errors.map((err) => {
    err instanceof Error ? (0, import_node_sdk2.sendErr)(err.message) : (0, import_node_sdk2.sendErr)(err);
  });
  (0, import_node_sdk2.sendErr)(`===`);
};
var configure = (dockerImage, dockerImageEnvVar, canUseLIGOBinary) => ({
  LIGO_DEFAULT_IMAGE: dockerImage,
  LIGO_IMAGE_ENV_VAR: dockerImageEnvVar,
  getLigoDockerImage: () => (0, import_node_sdk2.getDockerImage)(dockerImage, dockerImageEnvVar),
  baseDriverCmd: (projectDir) => baseDriverCmd(projectDir, dockerImage, canUseLIGOBinary)
});
function exists(path) {
  try {
    fs.accessSync(path, fs.constants.X_OK);
    return true;
  } catch {
    return false;
  }
}
function getLigoBinaryFromPath() {
  const { PATH } = process.env;
  if (!PATH) {
    return null;
  }
  const paths = PATH.split(import_path.delimiter);
  for (const candidatePath of paths) {
    const possibleLigoPath = (0, import_path.join)(candidatePath, "ligo");
    if (exists(possibleLigoPath)) {
      return possibleLigoPath;
    }
  }
  return null;
}
function baseDriverCmd(projectDir, ligoDockerImage, canUseLIGOBinary) {
  const ligoBinaryFromPath = canUseLIGOBinary ? getLigoBinaryFromPath() : null;
  if (ligoBinaryFromPath !== null) {
    return ligoBinaryFromPath;
  } else {
    return `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v "${projectDir}":/project -w /project -u $(id -u):$(id -g) ${ligoDockerImage}`;
  }
}

// compile.ts
var import_node_sdk3 = require("@taqueria/node-sdk");
var import_fs = require("fs");
var import_promises2 = require("fs/promises");
var import_path2 = require("path");
var readline = __toESM(require("readline"));
var COMPILE_ERR_MSG = "Not compiled";
var isStorageKind = (exprKind) => exprKind === "storage" || exprKind === "default_storage";
var isSupportedLigoSyntax = (sourceFile) => /\.(mligo|jsligo)$/.test(sourceFile);
var isUnsupportedLigoSyntax = (sourceFile) => /\.(ligo|religo)$/.test(sourceFile);
var isLIGOFile = (sourceFile) => isSupportedLigoSyntax(sourceFile) || isUnsupportedLigoSyntax(sourceFile);
var isStorageListFile = (sourceFile) => /.+\.(storageList|storages)\.(ligo|religo|mligo|jsligo)$/.test(sourceFile);
var isParameterListFile = (sourceFile) => /.+\.(parameterList|parameters)\.(ligo|religo|mligo|jsligo)$/.test(
  sourceFile
);
var extractExt = (path) => {
  const matchResult = path.match(/\.(ligo|religo|mligo|jsligo)$/);
  return matchResult ? matchResult[0] : "";
};
var removeExt = (path) => {
  const extRegex = new RegExp(extractExt(path));
  return path.replace(extRegex, "");
};
var isOutputFormatJSON = (parsedArgs) => parsedArgs.json;
var getOutputContractFilename = (parsedArgs, module2) => {
  const ext = isOutputFormatJSON(parsedArgs) ? ".json" : ".tz";
  return (0, import_path2.join)((0, import_node_sdk3.getArtifactsDir)(parsedArgs), `${module2.moduleName}${ext}`);
};
var getOutputExprFilename = (parsedArgs, module2, exprKind, exprName) => {
  const contractName = module2.moduleName;
  const ext = isOutputFormatJSON(parsedArgs) ? ".json" : ".tz";
  const outputFile = exprKind === "default_storage" ? `${contractName}.default_storage${ext}` : `${contractName}.${exprKind}.${exprName}${ext}`;
  return (0, import_path2.join)((0, import_node_sdk3.getArtifactsDir)(parsedArgs), `${outputFile}`);
};
var getExprNames = (parsedArgs, sourceFile) => {
  return new Promise((resolve, reject) => {
    const inputFilePath = getInputFilenameAbsPath(parsedArgs, sourceFile);
    const readInterface = readline.createInterface({
      input: (0, import_fs.createReadStream)(inputFilePath),
      output: process.stdout
    });
    const variableNames = [];
    readInterface.on("line", function(line) {
      if (!line.trim().startsWith("//")) {
        const matches = line.match(/(?<=\s*(let|const)\s+)[a-zA-Z0-9_]+/g);
        if (matches) {
          variableNames.push(...matches);
        }
      }
    });
    readInterface.on("close", function() {
      resolve(variableNames);
    });
  });
};
var getInitialMessage = (pair, module2) => {
  const messages = {
    "mligo-file-main": `// When this file was created, the smart contract was defined with a main function that was not within a named module. As such, the examples below are written with that assumption in mind.`,
    "mligo-file-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was not within a named module. As such, the examples below are written with that assumption in mind.`,
    "mligo-module-main": `// When this file was created, the smart contract was defined with a main function that was within a named module. As such, the examples below are written with that assumption in mind.`,
    "mligo-module-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was within a named module. As such, the examples below are written with that assumption in mind.`,
    "jsligo-file-main": `// When this file was created, the smart contract was defined with a main function that was not within a namespace. As such, the examples below are written with that assumption in mind.
// NOTE: The "storage" type should be exported from the contract file (${module2.sourceFile})`,
    "jsligo-file-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was not within a namespace. As such, the examples below are written with that assumption in mind.`,
    "jsligo-module-main": `// When this file was created, the smart contract was defined with a main function that was within a namespace. As such, the examples below are written with that assumption in mind.
// NOTE: The "storage" type should be exported from the contract file (${module2.sourceFile})`,
    "jsligo-module-entry": `// When this file was created, the smart contract was defined with an entrypoint using \`@entry\` that was within a namespace. As such, the examples below are written with that assumption in mind.`
    // ... any other combinations
  };
  return messages[pair] || "// This file was created by Taqueria.";
};
var getCommonMsg = (langType, listType) => {
  const varKeyword = langType === "mligo" ? "let" : "const";
  const commonMsgForStorage = `// IMPORTANT: We suggest always explicitly typing your storage values:
// E.g.: \`${varKeyword} storage: int = 10\` or \`${varKeyword} storage: Contract.storage = 10\``;
  const commonMsgForParameter = `// IMPORTANT: We suggest always explicitly typing your parameter values:
// E.g.: \`${varKeyword} parameter: int = 10\` or \`${varKeyword} parameter: Contract.parameter = 10\``;
  return listType === "storage" ? commonMsgForStorage : commonMsgForParameter;
};
var getContent = (moduleInfo, listType) => {
  const linkToContract = `#import "${moduleInfo.sourceFile}" "Contract"`;
  const pair = `${moduleInfo.syntax}-${moduleInfo.type}`;
  const initialMsg = getInitialMessage(pair, moduleInfo);
  const commonMsg = getCommonMsg(moduleInfo.syntax, listType);
  return `${linkToContract}

${initialMsg}

${commonMsg}`;
};
var initContentForStorage = (moduleInfo) => getContent(moduleInfo, "storage");
var initContentForParameter = (moduleInfo) => getContent(moduleInfo, "parameter");
var inject = (commonObj) => {
  const { getLigoDockerImage } = commonObj;
  const getListDeclarationsCmd = async (parsedArgs, sourceFile) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw new Error(`No project directory provided`);
    const baseCmd = `${commonObj.baseDriverCmd(projectDir)} info list-declarations`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const flags = "--display-format json";
    const cmd = `${baseCmd} ${inputFile} ${flags}`;
    return cmd;
  };
  const listContractModules = async (parsedArgs, sourceFile) => {
    try {
      await (0, import_node_sdk3.getArch)();
      const cmd = await getListDeclarationsCmd(parsedArgs, sourceFile);
      const { stderr, stdout } = await (0, import_node_sdk3.execCmd)(cmd);
      if (stderr.length > 0)
        return Promise.reject(stderr);
      return JSON.parse(stdout).declarations.reduce(
        (acc, decl) => {
          const srcFile = removeExt((0, import_path2.basename)(sourceFile));
          const syntax = extractExt(sourceFile).replace(".", "");
          if (decl === "main") {
            return [
              ...acc,
              {
                moduleName: srcFile,
                sourceName: sourceFile,
                sourceFile,
                type: "file-main",
                syntax
              }
            ];
          } else if (decl === "$main") {
            return [
              ...acc,
              {
                moduleName: srcFile,
                sourceName: sourceFile,
                sourceFile,
                type: "file-entry",
                syntax
              }
            ];
          } else if (decl.endsWith(".main")) {
            const moduleName = decl.replace(/\.main$/, "");
            return [
              ...acc,
              {
                moduleName,
                sourceName: `${sourceFile}/${moduleName}`,
                sourceFile,
                type: "module-main",
                syntax
              }
            ];
          } else if (decl.endsWith(".$main")) {
            const moduleName = decl.replace(/\.\$main$/, "");
            return [
              ...acc,
              {
                moduleName,
                sourceName: `${sourceFile}/${moduleName}`,
                sourceFile,
                type: "module-entry",
                syntax
              }
            ];
          }
          return acc;
        },
        []
      );
    } catch (err) {
      const formattedErr = err instanceof Error ? formatLigoError(err) : err;
      emitExternalError(err, sourceFile);
      return [];
    }
  };
  const getCompileContractCmd = async (parsedArgs, sourceFile, module2) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw new Error(`No project directory provided`);
    const baseCmd = `${commonObj.baseDriverCmd(projectDir)} compile contract`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const outputFile = `-o ${getOutputContractFilename(parsedArgs, module2)}`;
    const flags = isOutputFormatJSON(parsedArgs) ? " --michelson-format json " : "";
    const moduleFlag = module2.type.startsWith("file-") ? "" : `-m ${module2.moduleName}`;
    const cmd = `${baseCmd} ${inputFile} ${outputFile} ${flags}${moduleFlag}`;
    return cmd;
  };
  const compileContract = async (parsedArgs, sourceFile, module2) => {
    try {
      await (0, import_node_sdk3.getArch)();
      const cmd = await getCompileContractCmd(parsedArgs, sourceFile, module2);
      const { stderr } = await (0, import_node_sdk3.execCmd)(cmd);
      if (stderr.length > 0)
        (0, import_node_sdk3.sendWarn)(stderr);
      return {
        source: module2.sourceName,
        artifact: getOutputContractFilename(parsedArgs, module2)
      };
    } catch (err) {
      emitExternalError(err, sourceFile);
      return {
        source: module2.sourceName,
        artifact: COMPILE_ERR_MSG
      };
    }
  };
  const getCompileExprCmd = (parsedArgs, sourceFile, module2, exprKind, exprName) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw new Error(`No project directory provided`);
    const compilerType = isStorageKind(exprKind) ? "storage" : "parameter";
    const baseCmd = `${commonObj.baseDriverCmd(projectDir)} compile ${compilerType}`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const outputFile = `-o ${getOutputExprFilename(
      parsedArgs,
      module2,
      exprKind,
      exprName
    )}`;
    const flags = isOutputFormatJSON(parsedArgs) ? " --michelson-format json " : "";
    const moduleFlag = (() => {
      switch (module2.type) {
        case "file-main":
        case "file-entry":
          return "-m Contract";
        default:
          return `-m Contract.${module2.moduleName}`;
      }
    })();
    const cmd = `${baseCmd} ${inputFile} ${exprName} ${outputFile} ${flags} ${moduleFlag}`;
    return cmd;
  };
  const compileExpr = (parsedArgs, sourceFile, module2, exprKind) => (exprName) => {
    return (0, import_node_sdk3.getArch)().then(() => getCompileExprCmd(parsedArgs, sourceFile, module2, exprKind, exprName)).then(import_node_sdk3.execCmd).then(({ stderr }) => {
      if (stderr.length > 0)
        (0, import_node_sdk3.sendWarn)(stderr);
      const artifactName = getOutputExprFilename(
        parsedArgs,
        module2,
        exprKind,
        exprName
      );
      return {
        source: module2.sourceName,
        artifact: artifactName
      };
    }).catch((err) => {
      return {
        source: module2.sourceName,
        artifact: `${exprName} in ${sourceFile} not compiled`,
        err
      };
    });
  };
  const compileExprs = async (parsedArgs, sourceFile, module2, exprKind) => {
    let exprs = [];
    try {
      exprs = await getExprNames(parsedArgs, sourceFile);
    } catch (err) {
      emitExternalError(err, sourceFile);
      return [
        {
          source: module2.sourceName,
          artifact: `No ${isStorageKind(exprKind) ? "storage" : "parameter"} expressions compiled`
        }
      ];
    }
    const results = await Promise.all(
      exprs.map(async (exprName, index) => {
        const compileResult = await compileExpr(
          parsedArgs,
          sourceFile,
          module2,
          exprKind === "storage" && index === 0 ? "default_storage" : exprKind
        )(exprName);
        return compileResult;
      })
    );
    const errors = results.reduce((acc, result) => {
      if (result.err) {
        if (!(result.err instanceof Error))
          return [...acc, result.err];
        const ligoErrs = acc.filter((err) => err instanceof Error).map((err) => err.message);
        const formattedError = formatLigoError(result.err);
        return ligoErrs.includes(formattedError.message) ? acc : [...acc, formattedError];
      }
      return acc;
    }, []);
    const retval = results.map(({ source, artifact }) => ({
      source,
      artifact
    }));
    if (errors.length)
      emitExternalError(errors, sourceFile);
    return retval;
  };
  const compileContractWithStorageAndParameter = async (parsedArgs, sourceFile, module2) => {
    const contractCompileResult = await compileContract(
      parsedArgs,
      sourceFile,
      module2
    );
    if (contractCompileResult.artifact === COMPILE_ERR_MSG)
      return [contractCompileResult];
    const storageListFile = `${module2.moduleName}.storageList${extractExt(
      sourceFile
    )}`;
    const storageListFilename = getInputFilenameAbsPath(
      parsedArgs,
      storageListFile
    );
    const storageCompileResult = await (0, import_promises2.access)(storageListFilename).then(() => compileExprs(parsedArgs, storageListFile, module2, "storage")).catch(() => {
      (0, import_node_sdk3.sendWarn)(
        `Note: storage file associated with "${module2.moduleName}" can't be found, so "${storageListFile}" has been created for you. Use this file to define all initial storage values for this contract
`
      );
      return (0, import_promises2.writeFile)(
        storageListFilename,
        initContentForStorage(module2),
        "utf8"
      );
    });
    const parameterListFile = `${module2.moduleName}.parameterList${extractExt(
      sourceFile
    )}`;
    const parameterListFilename = getInputFilenameAbsPath(
      parsedArgs,
      parameterListFile
    );
    const parameterCompileResult = await (0, import_promises2.access)(parameterListFilename).then(() => compileExprs(parsedArgs, parameterListFile, module2, "parameter")).catch(() => {
      (0, import_node_sdk3.sendWarn)(
        `Note: parameter file associated with "${module2.moduleName}" can't be found, so "${parameterListFile}" has been created for you. Use this file to define all parameter values for this contract
`
      );
      return (0, import_promises2.writeFile)(
        parameterListFilename,
        initContentForParameter(module2),
        "utf8"
      );
    });
    const storageArtifacts = storageCompileResult ? storageCompileResult.map((res) => res.artifact).join("\n") : "";
    const parameterArtifacts = parameterCompileResult ? parameterCompileResult.map((res) => res.artifact).join("\n") : "";
    const combinedArtifact = [
      contractCompileResult.artifact,
      storageArtifacts,
      parameterArtifacts
    ].filter(Boolean).join("\n");
    const combinedRow = {
      source: module2.sourceName,
      artifact: combinedArtifact
    };
    return [combinedRow];
  };
  return {
    getLigoDockerImage,
    getListDeclarationsCmd,
    listContractModules,
    getCompileContractCmd,
    compileContract,
    getCompileExprCmd,
    compileExpr,
    compileExprs,
    compileContractWithStorageAndParameter
  };
};
var compile = async (commonObj, parsedArgs) => {
  const { listContractModules, compileContractWithStorageAndParameter } = inject(commonObj);
  const sourceFile = parsedArgs.sourceFile;
  if (!isLIGOFile(sourceFile)) {
    (0, import_node_sdk3.sendErr)(`${sourceFile} is not a LIGO file`);
    return;
  }
  if (isStorageListFile(sourceFile) || isParameterListFile(sourceFile)) {
    (0, import_node_sdk3.sendErr)(
      `Storage and parameter list files are not meant to be compiled directly`
    );
    return;
  }
  if (isUnsupportedLigoSyntax(sourceFile)) {
    (0, import_node_sdk3.sendErr)(
      `Unsupported LIGO syntax detected in ${sourceFile}. Note, we only support .jsligo and .mligo files.`
    );
    return;
  }
  try {
    const modules = await listContractModules(parsedArgs, sourceFile);
    if (modules.length === 0) {
      return (0, import_node_sdk3.sendJsonRes)([
        {
          source: sourceFile,
          artifact: `No contract modules found in "${sourceFile}".
If your contract is defined within a namespace, please ensure that it is exported from the contract file."`
        }
      ]);
    }
    let allCompileResults = [];
    for (const module2 of modules) {
      if (parsedArgs.module && parsedArgs.module !== module2.moduleName)
        continue;
      const compileResults = await compileContractWithStorageAndParameter(
        parsedArgs,
        sourceFile,
        module2
      );
      allCompileResults = allCompileResults.concat(compileResults);
    }
    (0, import_node_sdk3.sendJsonRes)(allCompileResults, {
      footer: `
Compiled ${allCompileResults.length} contract(s) in "${sourceFile}"`
    });
  } catch (err) {
    (0, import_node_sdk3.sendErr)(`Error processing "${sourceFile}": ${err}`);
  }
};
var compile_default = compile;

// compile-all.ts
var import_node_sdk4 = require("@taqueria/node-sdk");
var import_fast_glob = __toESM(require("fast-glob"));
var import_path3 = require("path");
var compileAll = async (commonObj, parsedArgs) => {
  const { listContractModules, compileContractWithStorageAndParameter } = inject(commonObj);
  let compilePromises = [];
  const contractFilenames = await (0, import_fast_glob.default)(
    ["**/*.ligo", "**/*.religo", "**/*.mligo", "**/*.jsligo"],
    {
      cwd: (0, import_path3.join)(parsedArgs.config.projectDir, parsedArgs.config.contractsDir ?? "contracts"),
      absolute: false
    }
  );
  for (const filename of contractFilenames) {
    if (isStorageListFile(filename) || isParameterListFile(filename))
      continue;
    const moduleNames = await listContractModules(parsedArgs, filename);
    for (const moduleName of moduleNames) {
      compilePromises.push(compileContractWithStorageAndParameter(parsedArgs, filename, moduleName));
    }
  }
  return Promise.all(compilePromises).then((tables) => tables.flat()).then(import_node_sdk4.sendJsonRes).catch((err) => (0, import_node_sdk4.sendErr)(err, false));
};
var compile_all_default = compileAll;

// ligo.ts
var import_node_sdk5 = require("@taqueria/node-sdk");
var getArbitraryLigoCmd = (commonObj, parsedArgs, userArgs) => {
  const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
  if (!projectDir)
    throw `No project directory provided`;
  const processedUserArgs = userArgs.split(" ").map((arg) => arg.startsWith("\\-") ? arg.substring(1) : arg).filter((arg) => arg);
  const cmd = `${commonObj.baseDriverCmd(projectDir)} ${processedUserArgs.join(" ")}`;
  const envVars = { DOCKER_DEFAULT_PLATFORM: "linux/amd64" };
  return [cmd, envVars];
};
var runArbitraryLigoCmd = (commonObj, parsedArgs, userCmd) => {
  let [cmd, envVars] = getArbitraryLigoCmd(commonObj, parsedArgs, userCmd);
  return (0, import_node_sdk5.spawnCmd)(cmd, envVars).then(
    (code) => code !== null && code === 0 ? `Command "${cmd}" ran successfully by LIGO` : `Command "${cmd}" failed. Please check your command`
  ).catch((err) => (0, import_node_sdk5.sendAsyncErr)(`An internal error has occurred: ${err.message}`));
};
var ligo = (commonObj, parsedArgs) => {
  const args = parsedArgs.command;
  return runArbitraryLigoCmd(commonObj, parsedArgs, args).then(import_node_sdk5.sendRes).catch((err) => (0, import_node_sdk5.sendAsyncErr)(err, false));
};
var ligo_default = ligo;

// test.ts
var import_node_sdk6 = require("@taqueria/node-sdk");
var inject2 = (commonObj) => {
  const { baseDriverCmd: baseDriverCmd2 } = commonObj;
  const getTestContractCmd = (parsedArgs, sourceFile) => {
    const projectDir = process.env.PROJECT_DIR ?? parsedArgs.projectDir;
    if (!projectDir)
      throw `No project directory provided`;
    const baseCmd = `${baseDriverCmd2(projectDir)} run test`;
    const inputFile = getInputFilenameRelPath(parsedArgs, sourceFile);
    const cmd = `${baseCmd} ${inputFile}`;
    return cmd;
  };
  const testContract = (parsedArgs, sourceFile) => (0, import_node_sdk6.getArch)().then(() => getTestContractCmd(parsedArgs, sourceFile)).then(import_node_sdk6.execCmd).then(({ stdout, stderr }) => {
    if (stderr.length > 0)
      (0, import_node_sdk6.sendWarn)(stderr);
    const result = "\u{1F389} All tests passed \u{1F389}";
    return {
      contract: sourceFile,
      testResults: stdout.length > 0 ? `${stdout}
${result}` : result
    };
  }).catch((err) => {
    emitExternalError(err, sourceFile);
    return {
      contract: sourceFile,
      testResults: "Some tests failed :("
    };
  });
  return {
    testContract,
    getTestContractCmd
  };
};
var test = (commonObj, parsedArgs) => {
  const { testContract } = inject2(commonObj);
  const sourceFile = parsedArgs.sourceFile;
  if (!sourceFile)
    return (0, import_node_sdk6.sendAsyncErr)(`No source file provided`);
  return testContract(parsedArgs, sourceFile).then((result) => [result]).then(import_node_sdk6.sendJsonRes).catch((err) => (0, import_node_sdk6.sendAsyncErr)(err, false));
};
var test_default = test;

// main.ts
var main = (dockerImage, dockerImageEnvVar, canUseLIGOBinary) => (parsedArgs) => {
  const commonObj = configure(dockerImage, dockerImageEnvVar, canUseLIGOBinary);
  const unsafeOpts = parsedArgs;
  switch (unsafeOpts.task) {
    case "ligo":
      return ligo_default(commonObj, unsafeOpts);
    case "compile":
      return compile_default(commonObj, unsafeOpts);
    case "compile-all":
      return compile_all_default(commonObj, unsafeOpts);
    case "test":
      return test_default(commonObj, parsedArgs);
    case "get-image":
      return (0, import_node_sdk7.sendAsyncRes)(commonObj.getLigoDockerImage());
    default:
      return (0, import_node_sdk7.sendAsyncErr)(`${unsafeOpts.task} is not an understood task by the LIGO plugin`);
  }
};
var main_default = main;

// index.ts
var configurePlugin = (settings) => {
  const schema = {
    name: settings.name,
    schema: "1.0",
    version: "0.1",
    alias: settings.alias,
    tasks: [
      import_node_sdk8.Task.create({
        task: "ligo",
        command: "ligo",
        description: "This task allows you to run arbitrary LIGO native commands. Note that they might not benefit from the abstractions provided by Taqueria",
        options: [
          import_node_sdk8.Option.create({
            shortFlag: "c",
            flag: "command",
            type: "string",
            description: "The command to be passed to the underlying LIGO binary, wrapped in quotes",
            required: true
          })
        ],
        handler: "proxy",
        encoding: "none"
      }),
      import_node_sdk8.Task.create({
        task: "compile",
        command: "compile <sourceFile>",
        aliases: ["c", "compile-ligo"],
        description: "Compile a smart contract written in a LIGO syntax to Michelson code, along with its associated storage/parameter list files if they are found",
        options: [
          import_node_sdk8.Option.create({
            flag: "json",
            boolean: true,
            description: "Emit JSON-encoded Michelson"
          }),
          import_node_sdk8.Option.create({
            flag: "module",
            shortFlag: "m",
            type: "string",
            description: "The LIGO module to be compiled"
          })
        ],
        handler: "proxy",
        encoding: "json"
      }),
      import_node_sdk8.Task.create({
        task: "compile-all",
        command: "compile-all",
        description: "Compile all main smart contracts written in a LIGO syntax to Michelson code, along with their associated storage/parameter list files if they are found",
        options: [
          import_node_sdk8.Option.create({
            flag: "json",
            boolean: true,
            description: "Emit JSON-encoded Michelson"
          })
        ],
        handler: "proxy",
        encoding: "json"
      }),
      import_node_sdk8.Task.create({
        task: "test",
        command: "test <sourceFile>",
        description: "Test a smart contract written in LIGO",
        handler: "proxy",
        encoding: "json"
      }),
      import_node_sdk8.Task.create({
        task: "get-image",
        command: "get-image",
        description: "Gets the name of the image to be used",
        handler: "proxy",
        hidden: true
      })
    ],
    templates: [
      import_node_sdk8.Template.create({
        template: "contract",
        command: "contract <sourceFileName>",
        description: "Create a LIGO contract with boilerplate code",
        positionals: [
          import_node_sdk8.PositionalArg.create({
            placeholder: "sourceFileName",
            type: "string",
            description: "The name of the LIGO contract to generate"
          })
        ],
        options: [
          import_node_sdk8.Option.create({
            shortFlag: "s",
            flag: "syntax",
            type: "string",
            description: "The syntax used in the contract"
          })
        ],
        handler: createContract_default(settings.templates)
      })
    ],
    proxy: main_default(settings.dockerImage, settings.dockerImageEnvVar, settings.canUseLIGOBinary),
    postInstall: `node ${__dirname}/postinstall.js`
  };
  return import_node_sdk8.Plugin.create(() => settings.configurator ? settings.configurator(schema) : schema, settings.unparsedArgs);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  configurePlugin
});
//# sourceMappingURL=index.js.map