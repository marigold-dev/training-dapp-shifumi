{ parameter
    (or (pair %revealPlay
           (nat %sessionId)
           (nat %roundId)
           (bytes %player_key)
           (nat %player_secret))
        (or (pair %play (nat %sessionId) (nat %roundId) (bytes %action))
            (or (nat %stopSession)
                (pair %createSession (nat %total_rounds) (list %players address))))) ;
  storage
    (pair (big_map %metadata string bytes)
          (nat %next_session)
          (map %sessions
             nat
             (pair (nat %total_rounds)
                   (list %players address)
                   (nat %current_round)
                   (map %rounds nat (list (pair (address %player) (bytes %action))))
                   (map %decoded_rounds
                      nat
                      (list (pair (address %player) (or %action (unit %stone) (or (unit %paper) (unit %cisor))))))
                   (map %board nat (option address))
                   (or %result (unit %inplay) (or (unit %draw) (address %winner)))
                   (timestamp %asleep)
                   (mutez %pool)))) ;
  code { PUSH string "Wrong current round parameter" ;
         PUSH string "Cannot find the contract from player address" ;
         LAMBDA
           (pair address (list address) string)
           unit
           { UNPAIR 3 ;
             DIG 2 ;
             NONE address ;
             DIG 3 ;
             LAMBDA (pair address address) bool { UNPAIR ; SWAP ; COMPARE ; EQ } ;
             DUP 5 ;
             APPLY ;
             DIG 4 ;
             DROP ;
             PAIR ;
             LEFT (option address) ;
             LOOP_LEFT
               { UNPAIR ;
                 SWAP ;
                 IF_CONS
                   { DUP ;
                     DUP 4 ;
                     SWAP ;
                     EXEC ;
                     IF { SWAP ;
                          DIG 2 ;
                          DROP 2 ;
                          SOME ;
                          RIGHT (pair (lambda address bool) (list address)) }
                        { DROP ; SWAP ; PAIR ; LEFT (option address) } }
                   { DROP ; NONE address ; RIGHT (pair (lambda address bool) (list address)) } } ;
             COMPARE ;
             NEQ ;
             IF { DROP ; UNIT } { FAILWITH } } ;
         LAMBDA
           (pair (or unit (or unit address)) (or unit (or unit address)))
           unit
           { UNPAIR ;
             COMPARE ;
             EQ ;
             IF { UNIT } { PUSH string "this session is finished" ; FAILWITH } } ;
         LAMBDA
           (pair (pair (big_map string bytes)
                       nat
                       (map nat
                            (pair nat
                                  (list address)
                                  nat
                                  (map nat (list (pair address bytes)))
                                  (map nat (list (pair address (or unit (or unit unit)))))
                                  (map nat (option address))
                                  (or unit (or unit address))
                                  timestamp
                                  mutez)))
                 nat
                 nat
                 (list address)
                 nat
                 (map nat (list (pair address bytes)))
                 (map nat (list (pair address (or unit (or unit unit)))))
                 (map nat (option address))
                 (or unit (or unit address))
                 timestamp
                 mutez)
           (pair (big_map string bytes)
                 nat
                 (map nat
                      (pair nat
                            (list address)
                            nat
                            (map nat (list (pair address bytes)))
                            (map nat (list (pair address (or unit (or unit unit)))))
                            (map nat (option address))
                            (or unit (or unit address))
                            timestamp
                            mutez)))
           { UNPAIR 3 ; DUP ; GET 4 ; DIG 3 ; SOME ; DIG 3 ; UPDATE ; UPDATE 4 } ;
         LAMBDA
           (pair nat
                 (big_map string bytes)
                 nat
                 (map nat
                      (pair nat
                            (list address)
                            nat
                            (map nat (list (pair address bytes)))
                            (map nat (list (pair address (or unit (or unit unit)))))
                            (map nat (option address))
                            (or unit (or unit address))
                            timestamp
                            mutez)))
           (pair nat
                 (list address)
                 nat
                 (map nat (list (pair address bytes)))
                 (map nat (list (pair address (or unit (or unit unit)))))
                 (map nat (option address))
                 (or unit (or unit address))
                 timestamp
                 mutez)
           { UNPAIR ;
             SWAP ;
             GET 4 ;
             SWAP ;
             GET ;
             IF_NONE { PUSH string "Unknown session" ; FAILWITH } {} } ;
         LAMBDA
           (pair (pair (lambda
                          (pair (pair (big_map string bytes)
                                      nat
                                      (map nat
                                           (pair nat
                                                 (list address)
                                                 nat
                                                 (map nat (list (pair address bytes)))
                                                 (map nat (list (pair address (or unit (or unit unit)))))
                                                 (map nat (option address))
                                                 (or unit (or unit address))
                                                 timestamp
                                                 mutez)))
                                nat
                                nat
                                (list address)
                                nat
                                (map nat (list (pair address bytes)))
                                (map nat (list (pair address (or unit (or unit unit)))))
                                (map nat (option address))
                                (or unit (or unit address))
                                timestamp
                                mutez)
                          (pair (big_map string bytes)
                                nat
                                (map nat
                                     (pair nat
                                           (list address)
                                           nat
                                           (map nat (list (pair address bytes)))
                                           (map nat (list (pair address (or unit (or unit unit)))))
                                           (map nat (option address))
                                           (or unit (or unit address))
                                           timestamp
                                           mutez))))
                       string)
                 (pair nat
                       (list address)
                       (pair nat
                             (list address)
                             nat
                             (map nat (list (pair address bytes)))
                             (map nat (list (pair address (or unit (or unit unit)))))
                             (map nat (option address))
                             (or unit (or unit address))
                             timestamp
                             mutez)
                       (big_map string bytes)
                       nat
                       (map nat
                            (pair nat
                                  (list address)
                                  nat
                                  (map nat (list (pair address bytes)))
                                  (map nat (list (pair address (or unit (or unit unit)))))
                                  (map nat (option address))
                                  (or unit (or unit address))
                                  timestamp
                                  mutez))))
           (pair (list operation)
                 (big_map string bytes)
                 nat
                 (map nat
                      (pair nat
                            (list address)
                            nat
                            (map nat (list (pair address bytes)))
                            (map nat (list (pair address (or unit (or unit unit)))))
                            (map nat (option address))
                            (or unit (or unit address))
                            timestamp
                            mutez)))
           { UNPAIR ;
             UNPAIR ;
             DIG 2 ;
             UNPAIR 4 ;
             PUSH nat 1 ;
             DUP 3 ;
             SIZE ;
             COMPARE ;
             EQ ;
             IF {}
                { PUSH string
                       "No players have played in the current round, thus cannot deduce troller" ;
                  FAILWITH } ;
             SWAP ;
             IF_CONS { SWAP ; DROP ; SOME } { NONE address } ;
             IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
             NIL address ;
             DUP 4 ;
             GET 3 ;
             LAMBDA (pair address address) bool { UNPAIR ; SWAP ; COMPARE ; EQ } ;
             DUP 4 ;
             APPLY ;
             DIG 3 ;
             DROP ;
             PAIR 3 ;
             LEFT (list address) ;
             LOOP_LEFT
               { UNPAIR 3 ;
                 SWAP ;
                 IF_CONS
                   { DUP ;
                     DUP 4 ;
                     SWAP ;
                     EXEC ;
                     IF { DIG 2 ;
                          DROP 2 ;
                          NIL address ;
                          DIG 2 ;
                          ITER { CONS } ;
                          NIL address ;
                          SWAP ;
                          ITER { CONS } ;
                          ITER { CONS } ;
                          RIGHT (pair (lambda address bool) (list address) (list address)) }
                        { DIG 3 ; SWAP ; CONS ; SWAP ; DIG 2 ; PAIR 3 ; LEFT (list address) } }
                   { DROP ;
                     NIL address ;
                     SWAP ;
                     ITER { CONS } ;
                     RIGHT (pair (lambda address bool) (list address) (list address)) } } ;
             IF_CONS { SWAP ; DROP ; SOME } { NONE address } ;
             IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
             DIG 2 ;
             DUP 2 ;
             RIGHT unit ;
             RIGHT unit ;
             UPDATE 13 ;
             DUP ;
             DUP 4 ;
             DIG 5 ;
             PAIR 3 ;
             DIG 4 ;
             SWAP ;
             EXEC ;
             DIG 4 ;
             DIG 3 ;
             CONTRACT unit ;
             IF_NONE { FAILWITH } { SWAP ; DROP } ;
             DIG 2 ;
             GET 16 ;
             UNIT ;
             TRANSFER_TOKENS ;
             SWAP ;
             NIL operation ;
             DIG 3 ;
             EMIT %gameStatus nat ;
             CONS ;
             DIG 2 ;
             CONS ;
             PAIR } ;
         DUP 6 ;
         DUP 4 ;
         PAIR ;
         APPLY ;
         DIG 7 ;
         UNPAIR ;
         IF_LEFT
           { DIG 2 ;
             DROP ;
             DUP 2 ;
             DUP 2 ;
             CAR ;
             PAIR ;
             DIG 3 ;
             SWAP ;
             EXEC ;
             PUSH string "Not allowed to reveal this session" ;
             DUP 2 ;
             GET 3 ;
             SENDER ;
             PAIR 3 ;
             DIG 6 ;
             SWAP ;
             EXEC ;
             DROP ;
             UNIT ;
             LEFT (or unit address) ;
             DUP 2 ;
             GET 13 ;
             PAIR ;
             DIG 5 ;
             SWAP ;
             EXEC ;
             DROP ;
             DIG 5 ;
             DUP 3 ;
             GET 3 ;
             DUP 3 ;
             GET 5 ;
             COMPARE ;
             EQ ;
             IF { DROP } { FAILWITH } ;
             DUP ;
             DUP 2 ;
             GET 5 ;
             SWAP ;
             GET 7 ;
             SWAP ;
             GET ;
             IF_NONE { PUSH string "no actions registered" ; FAILWITH } {} ;
             DUP 2 ;
             GET 3 ;
             SIZE ;
             PUSH nat 0 ;
             DUP 3 ;
             LAMBDA (pair nat address bytes) nat { CAR ; PUSH nat 1 ; ADD } ;
             DUG 2 ;
             ITER { SWAP ; PAIR ; DUP 2 ; SWAP ; EXEC } ;
             SWAP ;
             DROP ;
             PUSH string "a player has not played" ;
             SWAP ;
             DIG 2 ;
             COMPARE ;
             EQ ;
             IF { DROP } { FAILWITH } ;
             SOME ;
             SENDER ;
             PAIR ;
             LEFT (option bytes) ;
             LOOP_LEFT
               { UNPAIR ;
                 SWAP ;
                 IF_NONE
                   { DROP ; NONE bytes ; RIGHT (pair address (option (list (pair address bytes)))) }
                   { DUP ;
                     IF_CONS { SWAP ; DROP ; SOME } { NONE (pair address bytes) } ;
                     IF_NONE
                       { DROP 2 ; NONE bytes ; RIGHT (pair address (option (list (pair address bytes)))) }
                       { DUP 3 ;
                         DUP 2 ;
                         CAR ;
                         COMPARE ;
                         EQ ;
                         IF { SWAP ;
                              DIG 2 ;
                              DROP 2 ;
                              CDR ;
                              SOME ;
                              RIGHT (pair address (option (list (pair address bytes)))) }
                            { DROP ;
                              IF_CONS { DROP ; SOME } { NONE (list (pair address bytes)) } ;
                              SWAP ;
                              PAIR ;
                              LEFT (option bytes) } } } } ;
             IF_NONE { PUSH string "user has not played" ; FAILWITH } {} ;
             DUP 3 ;
             GET 6 ;
             SWAP ;
             DUP 4 ;
             GET 5 ;
             DIG 2 ;
             DUP 2 ;
             PAIR ;
             PACK ;
             SHA512 ;
             DIG 2 ;
             SWAP ;
             COMPARE ;
             EQ ;
             IF { UNPACK (or (unit %stone) (or (unit %paper) (unit %cisor))) ;
                  IF_NONE { PUSH string "Failed to unpack the payload" ; FAILWITH } {} }
                { DROP ; PUSH string "Failed to check bytes" ; FAILWITH } ;
             SENDER ;
             DUP 3 ;
             DUP 4 ;
             GET 5 ;
             DUP 2 ;
             GET 9 ;
             DUP 2 ;
             GET ;
             IF_NONE
               { SWAP ;
                 GET 9 ;
                 NIL (pair address (or unit (or unit unit))) ;
                 DIG 4 ;
                 DIG 4 ;
                 PAIR ;
                 CONS ;
                 DIG 2 ;
                 SWAP ;
                 SOME ;
                 SWAP ;
                 UPDATE }
               { PUSH string "You already have revealed your play for this round" ;
                 PUSH bool False ;
                 DUP 5 ;
                 GET 9 ;
                 DUP 5 ;
                 GET ;
                 IF_NONE
                   { PUSH bool False }
                   { PUSH bool False ;
                     SWAP ;
                     ITER { SWAP ;
                            DUP ;
                            IF { SWAP ; DROP } { DROP ; DUP 7 ; SWAP ; CAR ; COMPARE ; EQ } } } ;
                 COMPARE ;
                 EQ ;
                 IF { DROP } { FAILWITH } ;
                 DIG 2 ;
                 GET 9 ;
                 SWAP ;
                 DIG 4 ;
                 DIG 4 ;
                 PAIR ;
                 CONS ;
                 SOME ;
                 DIG 2 ;
                 UPDATE } ;
             DUP 2 ;
             PUSH int 600 ;
             NOW ;
             ADD ;
             UPDATE 15 ;
             SWAP ;
             UPDATE 9 ;
             DUP ;
             DUP ;
             GET 9 ;
             DUP 2 ;
             GET 5 ;
             GET ;
             IF_NONE { NIL (pair address (or unit (or unit unit))) } {} ;
             PUSH bool True ;
             PAIR ;
             DUP 2 ;
             GET 3 ;
             ITER { SWAP ;
                    UNPAIR ;
                    DUP 2 ;
                    PUSH bool False ;
                    DIG 3 ;
                    ITER { SWAP ;
                           DUP ;
                           IF { SWAP ; DROP } { DROP ; DUP 4 ; SWAP ; CAR ; COMPARE ; EQ } } ;
                    DIG 3 ;
                    DROP ;
                    DIG 2 ;
                    AND ;
                    PAIR } ;
             CAR ;
             PUSH bool True ;
             SWAP ;
             COMPARE ;
             EQ ;
             IF { DUP ;
                  PUSH nat 1 ;
                  DUP 3 ;
                  GET 5 ;
                  ADD ;
                  UPDATE 5 ;
                  DUP 2 ;
                  GET 5 ;
                  DUP 3 ;
                  GET 9 ;
                  DUP 2 ;
                  GET ;
                  IF_NONE { PUSH string "Missing actions for current_round" ; FAILWITH } {} ;
                  DUP ;
                  IF_CONS { SWAP ; DROP ; SOME } { NONE (pair address (or unit (or unit unit))) } ;
                  IF_NONE { PUSH string "Missing actions for first player" ; FAILWITH } {} ;
                  SWAP ;
                  IF_CONS { DROP ; SOME } { NONE (list (pair address (or unit (or unit unit)))) } ;
                  IF_NONE { PUSH string "Missing actions for second player" ; FAILWITH } {} ;
                  IF_CONS { SWAP ; DROP ; SOME } { NONE (pair address (or unit (or unit unit))) } ;
                  IF_NONE { PUSH string "Missing actions for second player" ; FAILWITH } {} ;
                  SWAP ;
                  DUP ;
                  CDR ;
                  IF_LEFT
                    { DROP ;
                      DUP 2 ;
                      CDR ;
                      IF_LEFT
                        { DROP 3 ; NONE address }
                        { IF_LEFT { DROP 2 ; CAR } { DIG 2 ; DROP 2 ; CAR } ; SOME } }
                    { IF_LEFT
                        { DROP ;
                          DUP 2 ;
                          CDR ;
                          IF_LEFT
                            { DIG 2 ; DROP 2 ; CAR ; SOME }
                            { SWAP ;
                              DROP ;
                              IF_LEFT { DROP 2 ; NONE address } { DROP ; CAR ; SOME } } }
                        { DROP ;
                          DUP 2 ;
                          CDR ;
                          IF_LEFT
                            { DROP 2 ; CAR ; SOME }
                            { DIG 2 ;
                              DROP ;
                              IF_LEFT { DROP ; CAR ; SOME } { DROP 2 ; NONE address } } } } ;
                  IF_NONE
                    { DIG 2 ; GET 11 ; NONE (option address) ; DIG 2 ; UPDATE }
                    { DIG 3 ; GET 11 ; SWAP ; SOME ; SOME ; DIG 2 ; UPDATE } ;
                  UPDATE 11 }
                {} ;
             DUP ;
             CAR ;
             DUP 2 ;
             GET 5 ;
             COMPARE ;
             GT ;
             IF { DUP ;
                  EMPTY_MAP address nat ;
                  DIG 2 ;
                  GET 11 ;
                  ITER { CDR ;
                         IF_NONE
                           {}
                           { DUP 2 ;
                             DUP 2 ;
                             GET ;
                             IF_NONE
                               { SWAP ; PUSH nat 1 ; DIG 2 ; SWAP ; SOME ; SWAP ; UPDATE }
                               { DIG 2 ; PUSH nat 1 ; DIG 2 ; ADD ; SOME ; DIG 2 ; UPDATE } } } ;
                  PUSH bool False ;
                  PUSH nat 0 ;
                  NONE address ;
                  PAIR 3 ;
                  SWAP ;
                  LAMBDA
                    (pair (pair (option address) nat bool) address nat)
                    (pair (option address) nat bool)
                    { UNPAIR ;
                      UNPAIR 3 ;
                      DUP ;
                      IF_NONE
                        { DROP 3 ; PUSH bool False ; DUP 2 ; CDR ; DIG 2 ; CAR ; SOME }
                        { DROP ;
                          DUP 2 ;
                          DUP 5 ;
                          CDR ;
                          COMPARE ;
                          GT ;
                          IF { DROP 3 ; PUSH bool False ; DUP 2 ; CDR ; DIG 2 ; CAR ; SOME }
                             { DUP 2 ;
                               DIG 4 ;
                               CDR ;
                               COMPARE ;
                               EQ ;
                               IF { DIG 2 ; DROP ; PUSH bool True } { DIG 2 } ;
                               DUG 2 } } ;
                      PAIR 3 } ;
                  DUG 2 ;
                  ITER { SWAP ; PAIR ; DUP 2 ; SWAP ; EXEC } ;
                  SWAP ;
                  DROP ;
                  UNPAIR 3 ;
                  SWAP ;
                  DROP ;
                  SWAP ;
                  IF { DROP ; UNIT ; LEFT address }
                     { IF_NONE { UNIT ; LEFT address } { RIGHT unit } } ;
                  RIGHT unit ;
                  UPDATE 13 }
                {} ;
             DUP ;
             DUP 5 ;
             CAR ;
             DIG 6 ;
             PAIR 3 ;
             DIG 5 ;
             SWAP ;
             EXEC ;
             DUP 2 ;
             GET 13 ;
             IF_LEFT
               { DIG 3 ;
                 DIG 6 ;
                 DROP 3 ;
                 DIG 2 ;
                 GET 5 ;
                 DIG 2 ;
                 GET 5 ;
                 COMPARE ;
                 EQ ;
                 IF { SWAP ; DROP ; NIL operation }
                    { NIL operation ; DIG 2 ; CAR ; EMIT %newRound nat ; CONS } }
               { DIG 2 ;
                 DIG 4 ;
                 DROP 2 ;
                 IF_LEFT
                   { DROP ;
                     DUP 4 ;
                     DUP 3 ;
                     GET 3 ;
                     IF_CONS { SWAP ; DROP ; SOME } { NONE address } ;
                     IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
                     CONTRACT unit ;
                     IF_NONE { FAILWITH } { SWAP ; DROP } ;
                     PUSH mutez 1000000 ;
                     PUSH mutez 2000000 ;
                     DUP 5 ;
                     GET 16 ;
                     EDIV ;
                     IF_NONE { PUSH string "DIV by 0" ; FAILWITH } {} ;
                     CAR ;
                     MUL ;
                     UNIT ;
                     TRANSFER_TOKENS ;
                     DIG 4 ;
                     DUP 4 ;
                     GET 3 ;
                     IF_CONS { DROP ; SOME } { NONE (list address) } ;
                     IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
                     IF_CONS { SWAP ; DROP ; SOME } { NONE address } ;
                     IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
                     CONTRACT unit ;
                     IF_NONE { FAILWITH } { SWAP ; DROP } ;
                     PUSH mutez 1000000 ;
                     PUSH mutez 2000000 ;
                     DIG 5 ;
                     GET 16 ;
                     EDIV ;
                     IF_NONE { PUSH string "DIV by 0" ; FAILWITH } {} ;
                     CAR ;
                     MUL ;
                     UNIT ;
                     TRANSFER_TOKENS ;
                     DIG 2 ;
                     NIL operation ;
                     DIG 4 ;
                     CAR ;
                     EMIT %gameStatus nat ;
                     CONS ;
                     DIG 2 }
                   { CONTRACT unit ;
                     IF_NONE { DIG 3 ; FAILWITH } { DIG 4 ; DROP } ;
                     DIG 2 ;
                     GET 16 ;
                     UNIT ;
                     TRANSFER_TOKENS ;
                     SWAP ;
                     NIL operation ;
                     DIG 3 ;
                     CAR ;
                     EMIT %gameStatus nat } ;
                 CONS ;
                 DIG 2 ;
                 CONS } ;
             PAIR }
           { IF_LEFT
               { DIG 2 ;
                 DIG 7 ;
                 DROP 2 ;
                 DUP 2 ;
                 DUP 2 ;
                 CAR ;
                 PAIR ;
                 DIG 3 ;
                 SWAP ;
                 EXEC ;
                 PUSH string "Not allowed to play this session" ;
                 DUP 2 ;
                 GET 3 ;
                 SENDER ;
                 PAIR 3 ;
                 DIG 6 ;
                 SWAP ;
                 EXEC ;
                 DROP ;
                 UNIT ;
                 LEFT (or unit address) ;
                 DUP 2 ;
                 GET 13 ;
                 PAIR ;
                 DIG 5 ;
                 SWAP ;
                 EXEC ;
                 DROP ;
                 DIG 4 ;
                 DUP 3 ;
                 GET 3 ;
                 DUP 3 ;
                 GET 5 ;
                 COMPARE ;
                 EQ ;
                 IF { DROP } { FAILWITH } ;
                 PUSH mutez 1000000 ;
                 AMOUNT ;
                 COMPARE ;
                 LT ;
                 IF { DROP 4 ;
                      PUSH string "Player needs to pay 1 Tez to play a round" ;
                      FAILWITH }
                    { DUP 2 ;
                      GET 4 ;
                      SENDER ;
                      DUP 3 ;
                      DUP 4 ;
                      GET 5 ;
                      DUP 2 ;
                      GET 7 ;
                      DUP 2 ;
                      GET ;
                      IF_NONE
                        { SWAP ;
                          GET 7 ;
                          NIL (pair address bytes) ;
                          DIG 4 ;
                          DIG 4 ;
                          PAIR ;
                          CONS ;
                          DIG 2 ;
                          SWAP ;
                          SOME ;
                          SWAP ;
                          UPDATE }
                        { PUSH string "You already have played for this round" ;
                          PUSH bool False ;
                          DUP 5 ;
                          GET 7 ;
                          DUP 5 ;
                          GET ;
                          IF_NONE
                            { PUSH bool False }
                            { PUSH bool False ;
                              SWAP ;
                              ITER { SWAP ;
                                     DUP ;
                                     IF { SWAP ; DROP } { DROP ; DUP 7 ; SWAP ; CAR ; COMPARE ; EQ } } } ;
                          COMPARE ;
                          EQ ;
                          IF { DROP } { FAILWITH } ;
                          DIG 2 ;
                          GET 7 ;
                          SWAP ;
                          DIG 4 ;
                          DIG 4 ;
                          PAIR ;
                          CONS ;
                          SOME ;
                          DIG 2 ;
                          UPDATE } ;
                      DUP 2 ;
                      PUSH mutez 1000000 ;
                      DIG 3 ;
                      GET 16 ;
                      ADD ;
                      UPDATE 16 ;
                      PUSH int 600 ;
                      NOW ;
                      ADD ;
                      UPDATE 15 ;
                      SWAP ;
                      UPDATE 7 ;
                      DUP ;
                      DUP 3 ;
                      CAR ;
                      DIG 4 ;
                      PAIR 3 ;
                      DIG 3 ;
                      SWAP ;
                      EXEC ;
                      DUP 2 ;
                      GET 7 ;
                      DIG 2 ;
                      GET 5 ;
                      GET ;
                      IF_NONE
                        { SWAP ; DROP ; NIL operation }
                        { PUSH nat 2 ;
                          SWAP ;
                          SIZE ;
                          COMPARE ;
                          NEQ ;
                          IF { SWAP ; DROP ; NIL operation }
                             { NIL operation ; DIG 2 ; CAR ; EMIT %reveal nat ; CONS } } ;
                      PAIR } }
               { DIG 8 ;
                 DROP ;
                 IF_LEFT
                   { DUP 2 ;
                     DUP 2 ;
                     PAIR ;
                     DIG 4 ;
                     SWAP ;
                     EXEC ;
                     PUSH string "Not allowed to stop this session" ;
                     DUP 2 ;
                     GET 3 ;
                     SENDER ;
                     PAIR 3 ;
                     DIG 7 ;
                     SWAP ;
                     EXEC ;
                     DROP ;
                     UNIT ;
                     LEFT (or unit address) ;
                     DUP 2 ;
                     GET 13 ;
                     PAIR ;
                     DIG 6 ;
                     SWAP ;
                     EXEC ;
                     DROP ;
                     DUP ;
                     PUSH string
                          "Must wait at least 600 seconds before claiming Victory (in case opponent is not playing)" ;
                     SWAP ;
                     GET 15 ;
                     NOW ;
                     COMPARE ;
                     GT ;
                     IF { DROP } { FAILWITH } ;
                     DUP ;
                     GET 7 ;
                     DUP 2 ;
                     GET 5 ;
                     GET ;
                     IF_NONE { NIL (pair address bytes) } {} ;
                     DUP 2 ;
                     GET 3 ;
                     SWAP ;
                     NIL address ;
                     DIG 2 ;
                     ITER { SWAP ;
                            DUP 3 ;
                            LAMBDA
                              (pair address (pair address bytes))
                              bool
                              { UNPAIR ; SWAP ; CAR ; COMPARE ; EQ } ;
                            DUP 4 ;
                            APPLY ;
                            PAIR ;
                            LEFT (option (pair address bytes)) ;
                            LOOP_LEFT
                              { UNPAIR ;
                                SWAP ;
                                IF_CONS
                                  { DUP ;
                                    DUP 4 ;
                                    SWAP ;
                                    EXEC ;
                                    IF { SWAP ;
                                         DIG 2 ;
                                         DROP 2 ;
                                         SOME ;
                                         RIGHT (pair (lambda (pair address bytes) bool) (list (pair address bytes))) }
                                       { DROP ; SWAP ; PAIR ; LEFT (option (pair address bytes)) } }
                                  { DROP ;
                                    NONE (pair address bytes) ;
                                    RIGHT (pair (lambda (pair address bytes) bool) (list (pair address bytes))) } } ;
                            IF_NONE { SWAP ; CONS } { DIG 2 ; DROP 2 } } ;
                     SWAP ;
                     DROP ;
                     PUSH nat 0 ;
                     DUP 2 ;
                     SIZE ;
                     COMPARE ;
                     GT ;
                     IF { DIG 5 ; DIG 6 ; DROP 2 ; DIG 3 ; DUG 2 ; DIG 3 ; PAIR 4 ; EXEC }
                        { DROP ;
                          DUP ;
                          GET 9 ;
                          DUP 2 ;
                          GET 5 ;
                          GET ;
                          DUP ;
                          IF_NONE { PUSH bool True } { DROP ; PUSH bool False } ;
                          IF { DIG 4 ;
                               DROP 2 ;
                               DIG 2 ;
                               SWAP ;
                               DIG 2 ;
                               SWAP ;
                               UNIT ;
                               LEFT address ;
                               RIGHT unit ;
                               UPDATE 13 ;
                               DUP ;
                               DUP 3 ;
                               DIG 4 ;
                               PAIR 3 ;
                               DIG 3 ;
                               SWAP ;
                               EXEC ;
                               DUP 4 ;
                               DUP 3 ;
                               GET 3 ;
                               IF_CONS { SWAP ; DROP ; SOME } { NONE address } ;
                               IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
                               CONTRACT unit ;
                               IF_NONE { FAILWITH } { SWAP ; DROP } ;
                               PUSH mutez 1000000 ;
                               PUSH mutez 2000000 ;
                               DUP 5 ;
                               GET 16 ;
                               EDIV ;
                               IF_NONE { PUSH string "DIV by 0" ; FAILWITH } {} ;
                               CAR ;
                               MUL ;
                               UNIT ;
                               TRANSFER_TOKENS ;
                               DIG 4 ;
                               DUP 4 ;
                               GET 3 ;
                               IF_CONS { DROP ; SOME } { NONE (list address) } ;
                               IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
                               IF_CONS { SWAP ; DROP ; SOME } { NONE address } ;
                               IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
                               CONTRACT unit ;
                               IF_NONE { FAILWITH } { SWAP ; DROP } ;
                               PUSH mutez 1000000 ;
                               PUSH mutez 2000000 ;
                               DIG 5 ;
                               GET 16 ;
                               EDIV ;
                               IF_NONE { PUSH string "DIV by 0" ; FAILWITH } {} ;
                               CAR ;
                               MUL ;
                               UNIT ;
                               TRANSFER_TOKENS ;
                               DIG 2 ;
                               NIL operation ;
                               DIG 4 ;
                               EMIT %gameStatus nat ;
                               CONS ;
                               DIG 2 ;
                               CONS ;
                               DIG 2 ;
                               CONS ;
                               PAIR }
                             { DIG 5 ;
                               DIG 6 ;
                               DROP 2 ;
                               IF_NONE { PUSH string "option is None" ; FAILWITH } {} ;
                               DUP 2 ;
                               GET 3 ;
                               SWAP ;
                               NIL address ;
                               DIG 2 ;
                               ITER { SWAP ;
                                      DUP 3 ;
                                      LAMBDA
                                        (pair address (pair address (or unit (or unit unit))))
                                        bool
                                        { UNPAIR ; SWAP ; CAR ; COMPARE ; EQ } ;
                                      DUP 4 ;
                                      APPLY ;
                                      PAIR ;
                                      LEFT (option (pair address (or unit (or unit unit)))) ;
                                      LOOP_LEFT
                                        { UNPAIR ;
                                          SWAP ;
                                          IF_CONS
                                            { DUP ;
                                              DUP 4 ;
                                              SWAP ;
                                              EXEC ;
                                              IF { SWAP ;
                                                   DIG 2 ;
                                                   DROP 2 ;
                                                   SOME ;
                                                   RIGHT
                                                     (pair (lambda (pair address (or unit (or unit unit))) bool)
                                                           (list (pair address (or unit (or unit unit))))) }
                                                 { DROP ; SWAP ; PAIR ; LEFT (option (pair address (or unit (or unit unit)))) } }
                                            { DROP ;
                                              NONE (pair address (or unit (or unit unit))) ;
                                              RIGHT
                                                (pair (lambda (pair address (or unit (or unit unit))) bool)
                                                      (list (pair address (or unit (or unit unit))))) } } ;
                                      IF_NONE { SWAP ; CONS } { DIG 2 ; DROP 2 } } ;
                               SWAP ;
                               DROP ;
                               PUSH nat 0 ;
                               DUP 2 ;
                               SIZE ;
                               COMPARE ;
                               GT ;
                               IF { DIG 3 ; DUG 2 ; DIG 3 ; PAIR 4 ; EXEC }
                                  { SWAP ; DIG 2 ; DIG 4 ; DROP 4 ; NIL operation ; PAIR } } } }
                   { DIG 2 ;
                     DIG 3 ;
                     DIG 4 ;
                     DIG 5 ;
                     DIG 6 ;
                     DIG 7 ;
                     DROP 6 ;
                     UNPAIR ;
                     PUSH mutez 0 ;
                     PUSH int 600 ;
                     NOW ;
                     ADD ;
                     UNIT ;
                     LEFT (or unit address) ;
                     EMPTY_MAP nat (option address) ;
                     EMPTY_MAP nat (list (pair address (or unit (or unit unit)))) ;
                     EMPTY_MAP nat (list (pair address bytes)) ;
                     PUSH nat 1 ;
                     DIG 8 ;
                     DIG 8 ;
                     PAIR 9 ;
                     DUP 2 ;
                     PUSH nat 1 ;
                     DUP 4 ;
                     GET 3 ;
                     ADD ;
                     UPDATE 3 ;
                     DUP 3 ;
                     GET 4 ;
                     DIG 2 ;
                     DIG 3 ;
                     GET 3 ;
                     SWAP ;
                     SOME ;
                     SWAP ;
                     UPDATE ;
                     UPDATE 4 ;
                     NIL operation ;
                     PAIR } } } } ;
  view "board"
       nat
       (map address nat)
       { UNPAIR ;
         SWAP ;
         GET 4 ;
         SWAP ;
         GET ;
         IF_NONE
           { PUSH string "Unknown session" ; FAILWITH }
           { EMPTY_MAP address nat ;
             SWAP ;
             GET 11 ;
             ITER { CDR ;
                    IF_NONE
                      {}
                      { DUP 2 ;
                        DUP 2 ;
                        GET ;
                        IF_NONE
                          { SWAP ; PUSH nat 1 ; DIG 2 ; SWAP ; SOME ; SWAP ; UPDATE }
                          { DIG 2 ; PUSH nat 1 ; DIG 2 ; ADD ; SOME ; DIG 2 ; UPDATE } } } } } }

