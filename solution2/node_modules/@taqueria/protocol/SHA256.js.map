{"version":3,"sources":["SHA256.ts"],"sourcesContent":["import createType from '@taqueria/protocol/Base';\nimport { E_TaqError, TaqError } from '@taqueria/protocol/TaqError';\nimport { FutureInstance as Future, mapRej, promise } from 'fluture';\nimport { has } from 'rambda';\nimport { TextEncoder } from 'util';\nimport { z } from 'zod';\n\nconst eager = <T>(f: Future<TaqError, T>) =>\n\tpromise(\n\t\tmapRej((err: TaqError) => new E_TaqError(err))(f),\n\t);\n\n// Access to SubtleCrypto is different on NodeJS vs Deno\ninterface SubtleCrypto {\n\tdigest(method: 'SHA-256', data: Uint8Array): ArrayBuffer;\n}\nexport class Crypto {\n\tsubtle: SubtleCrypto;\n\tconstructor() {\n\t\tthis.subtle = {\n\t\t\tdigest(_method: 'SHA-256', _data: Uint8Array) {\n\t\t\t\treturn new ArrayBuffer(50);\n\t\t\t},\n\t\t};\n\t}\n}\n// deno-lint-ignore var\ndeclare var crypto: Crypto;\n\nconst getSubtleCrypto = async () => {\n\tif (has('SubtleCrypto', globalThis)) {\n\t\treturn Promise.resolve(crypto.subtle);\n\t}\n\n\tconst { Crypto } = await import('@peculiar/webcrypto');\n\tconst webcrypto = new Crypto();\n\treturn Promise.resolve(webcrypto.subtle);\n};\n\nexport const rawSchema = z.string({ description: 'SHA256' }).length(64);\n\ntype RawInput = z.infer<typeof rawSchema>;\n\nconst { schemas: generatedSchemas, factory } = createType<RawInput, RawInput>({\n\tisStringLike: true,\n\trawSchema,\n\tparseErrMsg: (value: unknown) => `${value} is an invalid SHA256 hash`,\n\tunknownErrMsg: (value: unknown) => `Something went wrong trying to parse the following as a SHA256 value, ${value}`,\n});\n\nexport const toSHA256 = async (value: string) => {\n\tconst encoder = new TextEncoder();\n\tconst data = encoder.encode(value);\n\tconst hash = await (await getSubtleCrypto()).digest('SHA-256', data);\n\tconst hashArray = Array.from(new Uint8Array(hash)); // convert buffer to byte array\n\tconst hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\treturn eager(factory.make(hashHex));\n};\n\nexport const internalSchema = generatedSchemas.schema;\n\nexport type SHA256 = z.infer<typeof internalSchema>;\nexport type t = SHA256;\nexport const { create, of, make } = factory;\nexport const schemas = {\n\t...generatedSchemas,\n\tschema: generatedSchemas.schema.transform(val => val as SHA256),\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAuB;AACvB,sBAAqC;AACrC,qBAA0D;AAC1D,oBAAoB;AACpB,kBAA4B;AAC5B,iBAAkB;AAElB,IAAM,QAAQ,CAAI,UACjB;AAAA,MACC,uBAAO,CAAC,QAAkB,IAAI,2BAAW,GAAG,CAAC,EAAE,CAAC;AACjD;AAMM,IAAM,SAAN,MAAa;AAAA,EAEnB,cAAc;AACb,SAAK,SAAS;AAAA,MACb,OAAO,SAAoB,OAAmB;AAC7C,eAAO,IAAI,YAAY,EAAE;AAAA,MAC1B;AAAA,IACD;AAAA,EACD;AACD;AAIA,IAAM,kBAAkB,YAAY;AACnC,UAAI,mBAAI,gBAAgB,UAAU,GAAG;AACpC,WAAO,QAAQ,QAAQ,OAAO,MAAM;AAAA,EACrC;AAEA,QAAM,EAAE,QAAAA,QAAO,IAAI,MAAM,OAAO;AAChC,QAAM,YAAY,IAAIA,QAAO;AAC7B,SAAO,QAAQ,QAAQ,UAAU,MAAM;AACxC;AAEO,IAAM,YAAY,aAAE,OAAO,EAAE,aAAa,SAAS,CAAC,EAAE,OAAO,EAAE;AAItE,IAAM,EAAE,SAAS,kBAAkB,QAAQ,QAAI,YAAAC,SAA+B;AAAA,EAC7E,cAAc;AAAA,EACd;AAAA,EACA,aAAa,CAAC,UAAmB,GAAG;AAAA,EACpC,eAAe,CAAC,UAAmB,yEAAyE;AAC7G,CAAC;AAEM,IAAM,WAAW,OAAO,UAAkB;AAChD,QAAM,UAAU,IAAI,wBAAY;AAChC,QAAM,OAAO,QAAQ,OAAO,KAAK;AACjC,QAAM,OAAO,OAAO,MAAM,gBAAgB,GAAG,OAAO,WAAW,IAAI;AACnE,QAAM,YAAY,MAAM,KAAK,IAAI,WAAW,IAAI,CAAC;AACjD,QAAM,UAAU,UAAU,IAAI,OAAK,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AAC3E,SAAO,MAAM,QAAQ,KAAK,OAAO,CAAC;AACnC;AAEO,IAAM,iBAAiB,iBAAiB;AAIxC,IAAM,EAAE,QAAQ,IAAI,KAAK,IAAI;AAC7B,IAAM,UAAU;AAAA,EACtB,GAAG;AAAA,EACH,QAAQ,iBAAiB,OAAO,UAAU,SAAO,GAAa;AAC/D;","names":["Crypto","createType"]}