"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// EphemeralState.ts
var EphemeralState_exports = {};
__export(EphemeralState_exports, {
  create: () => create,
  factory: () => factory,
  generatedSchemas: () => generatedSchemas,
  getTasks: () => getTasks,
  make: () => make,
  mapOperationsToPlugins: () => mapOperationsToPlugins,
  mapTasksToPlugins: () => mapTasksToPlugins,
  mapTemplatesToPlugins: () => mapTemplatesToPlugins,
  of: () => of,
  schemas: () => schemas
});
module.exports = __toCommonJS(EphemeralState_exports);
var import_protocol = require("@taqueria/protocol");
var import_Base = __toESM(require("@taqueria/protocol/Base"));
var import_TaqError = require("@taqueria/protocol/TaqError");
var import_fluture = require("fluture");
var import_zod = require("zod");
var eager = (f) => (0, import_fluture.promise)(
  (0, import_fluture.mapRej)((err) => new import_TaqError.E_TaqError(err))(f)
);
var taskToPluginMap = import_zod.z.record(
  import_zod.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.Task.schemas.schema
  ], { description: "Task/Plugin Mapping" })
);
var operationToPluginMap = import_zod.z.record(
  import_zod.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.ParsedOperation.schemas.schema
  ], { description: "Operation/Plugin Mapping" })
);
var templateToPluginMap = import_zod.z.record(
  import_zod.z.union([
    import_protocol.InstalledPlugin.schemas.schema,
    import_protocol.ParsedTemplate.schemas.schema
  ])
);
var rawSchema = import_zod.z.object({
  build: import_zod.z.string({ description: "cache.build" }),
  configHash: import_zod.z.string({ description: "cache.configHash" }),
  tasks: taskToPluginMap,
  operations: operationToPluginMap,
  templates: templateToPluginMap,
  plugins: import_zod.z.array(import_protocol.PluginInfo.schemas.schema, { description: "cache.plugins" })
}).describe("Ephemeral State");
var { schemas: generatedSchemas, factory } = (0, import_Base.default)({
  rawSchema,
  parseErrMsg: (value) => `${value} is not a valid representation of ephemeral state`,
  unknownErrMsg: "Something went wrong when parsing the ephemeral state"
});
var { create, of, make } = factory;
var schemas = {
  ...generatedSchemas,
  schema: generatedSchemas.schema.transform((val) => val)
};
var getTaskCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.tasks === void 0 ? {} : pluginInfo2.tasks.reduce(
      (retval2, task) => {
        const taskName = task.task;
        const providers = retval2[taskName] ? [...retval2[taskName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[taskName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getTemplateCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => !pluginInfo2.templates ? retval : pluginInfo2.templates.reduce(
      (retval2, template) => {
        const templateName = template.template;
        const providers = retval2[templateName] ? [...retval2[templateName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[templateName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getOperationCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.operations === void 0 ? retval : pluginInfo2.operations.reduce(
      (retval2, operation) => {
        const operationName = operation.operation;
        const providers = retval2[operationName] ? [...retval2[operationName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[operationName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var toChoices = (plugins) => plugins.reduce(
  (retval, pluginInfo) => {
    return [...retval, pluginInfo.name, pluginInfo.alias];
  },
  []
);
var isComposite = (name, counts) => counts[name] && counts[name].length > 1;
var getInstalledPlugin = (config, name) => {
  var _a;
  return (_a = config.plugins) == null ? void 0 : _a.find(
    (plugin) => [`taqueria-plugin-${name}`, name].includes(plugin.name)
  );
};
var mapTasksToPlugins = (config, pluginInfo, i18n) => {
  const taskCounts = getTaskCounts(pluginInfo);
  return (0, import_fluture.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.tasks ? Promise.resolve({}) : await pluginInfo2.tasks.reduce(
        async (retval2, { task, hidden }) => {
          if (isComposite(task, taskCounts)) {
            const command = await eager(import_protocol.Command.make(task));
            const compositeTask = await eager(import_protocol.Task.make({
              task,
              command,
              description: await eager(import_protocol.NonEmptyString.make(i18n.__("providedByMany"))),
              hidden,
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this task")
                  ),
                  choices: toChoices(taskCounts[task]),
                  required: true
                }))
              ],
              handler: "proxy"
            }));
            return { ...await retval2, [task]: compositeTask };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [task]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture.mapRej)((rej) => rej));
};
var mapOperationsToPlugins = (config, pluginInfo, i18n) => {
  const opCounts = getOperationCounts(pluginInfo);
  return (0, import_fluture.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.operations ? Promise.resolve({}) : await pluginInfo2.operations.reduce(
        async (retval2, { operation }) => {
          if (isComposite(operation, opCounts)) {
            const command = await eager(import_protocol.Command.make(operation));
            const compositeOp = await eager(import_protocol.ParsedOperation.make({
              operation,
              command,
              description: await eager(import_protocol.NonEmptyString.make(i18n.__("providedByMany"))),
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this operation")
                  ),
                  choices: toChoices(opCounts[operation]),
                  required: true
                }))
              ]
            }));
            return { ...await retval2, [operation]: compositeOp };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [operation]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture.mapRej)((rej) => rej));
};
var mapTemplatesToPlugins = (config, pluginInfo, i18n) => {
  const tmplCounts = getTemplateCounts(pluginInfo);
  return (0, import_fluture.attemptP)(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.templates ? Promise.resolve({}) : await pluginInfo2.templates.reduce(
        async (retval2, { template, hidden }) => {
          if (isComposite(template, tmplCounts)) {
            const command = await eager(import_protocol.Command.make(template));
            const description = await eager(import_protocol.NonEmptyString.of(i18n.__("providedByMany")));
            const compositeTmpl = await eager(import_protocol.ParsedTemplate.make({
              template,
              command,
              description,
              options: [
                await eager(import_protocol.Option.make({
                  flag: await eager(import_protocol.Verb.make("plugin")),
                  description: await eager(
                    import_protocol.NonEmptyString.make("Specify which plugin should be used to execute this task")
                  ),
                  choices: toChoices(tmplCounts[template]),
                  required: true
                }))
              ],
              handler: "proxy",
              encoding: import_protocol.PluginResponseEncoding.create("none")
            }));
            return { ...await retval2, [template]: compositeTmpl };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [template]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe((0, import_fluture.mapRej)((rej) => rej));
};
var getTasks = (pluginInfo) => pluginInfo.reduce(
  (retval, pluginInfo2) => {
    var _a;
    return [...retval, ...(_a = pluginInfo2.tasks) != null ? _a : []];
  },
  []
);
//# sourceMappingURL=EphemeralState.js.map